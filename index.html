<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Global Supply Chain Tycoon</title>
    <style>
        :root {
            --bg-color: #0d1117;
            --panel-bg: rgba(22, 27, 34, 0.95);
            --panel-border: rgba(48, 54, 61, 0.6);
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-family);
            color: var(--text-primary);
            user-select: none;
            -webkit-font-smoothing: antialiased;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #map-svg, #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #map-svg { z-index: 1; pointer-events: all; }
        #game-canvas { z-index: 2; pointer-events: none; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        /* Ensure interactive elements catch clicks */
        #selection-sheet, .fab-btn, .switch, button {
            pointer-events: auto;
        }

        #status-bar {
            width: 100%;
            padding: 16px 20px;
            box-sizing: border-box;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.9) 0%, rgba(13, 17, 23, 0) 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .stat-label {
            font-size: 11px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: var(--text-secondary);
            font-weight: 700;
        }
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            letter-spacing: -0.5px;
        }

        #notification-area {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            z-index: 20;
        }
        .toast {
            background: rgba(22, 27, 34, 0.7);
            /* backdrop-filter: blur(8px); REMOVED for performance */
            border: 1px solid var(--panel-border);
            padding: 6px 12px;
            border-radius: 30px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: toastIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .toast-icon { font-size: 16px; }
        .toast.warn { border-bottom: 2px solid var(--accent-red); }
        .toast.info { border-bottom: 2px solid var(--accent-blue); }

        @keyframes toastIn {
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        #bottom-area {
            padding: 20px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            position: relative;
        }

        .fab-container {
            pointer-events: auto;
            position: absolute;
            top: 80px; /* Below Timeline */
            right: 20px;
            display: flex;
            flex-direction: column; /* Vertical layout */
            align-items: center;
            gap: 4px;
            z-index: 30;
        }
        
        .zoom-controls {
            pointer-events: auto;
            position: absolute;
            top: 80px; /* Below Net Cash */
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 20;
            background: rgba(22, 27, 34, 0.8);
            padding: 2px;
            border-radius: 30px;
            border: 1px solid var(--panel-border);
        }
        
        .legend-container {
            pointer-events: auto;
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(22, 27, 34, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--panel-border);
            display: flex;
            align-items: center;
            justify-content: center; /* Center items */
            flex-wrap: wrap; /* Allow wrapping */
            gap: 12px;
            width: max-content; /* Fit content */
            max-width: 90vw; /* Prevent overflow */
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .legend-divider {
            width: 1px;
            height: 12px;
            background: rgba(255,255,255,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .fab-menu {
            display: flex;
            flex-direction: column; /* Vertical layout */
            gap: 4px;
            opacity: 1;
            transform: none;
            pointer-events: auto;
            background: rgba(22, 27, 34, 0.8);
            padding: 2px;
            border-radius: 30px;
            border: 1px solid var(--panel-border);
        }
        
        .fab-btn {
            width: 40px; /* Slightly smaller */
            height: 40px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-family: var(--font-family);
            font-size: 14px;
        }
        .fab-btn:active { transform: scale(0.92); }
        .fab-btn.active { 
            background: var(--accent-blue); 
            color: white; 
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        .fab-main { display: none !important; } /* Hide the lightning button */

        #selection-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--panel-bg);
            /* backdrop-filter: blur(12px); REMOVED for performance */
            border-top: 1px solid var(--panel-border);
            border-radius: 24px 24px 0 0;
            box-shadow: 0 -8px 32px rgba(0,0,0,0.5);
            transform: translateY(110%);
            transition: transform 0.35s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: auto;
            max-height: 85vh; /* Increased from 70vh to allow more space */
            display: flex;
            flex-direction: column;
            z-index: 100;
        }
        #selection-sheet.active {
            transform: translateY(0);
        }

        .sheet-handle {
            width: 40px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 12px auto 4px auto;
        }

        .sheet-header {
            padding: 12px 24px 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .sheet-title {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        .close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sheet-content {
            padding: 0 24px 80px 24px; /* Increased padding to clear system UI */
            flex: 1; /* Take remaining height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y; /* Explicitly allow vertical scroll */
            overscroll-behavior: contain; /* Prevent scroll chaining to body */
            padding-bottom: max(100px, env(safe-area-inset-bottom)); /* More padding for scroll */
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        .stat-card {
            background: rgba(255,255,255,0.03);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
        }
        .stat-card-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; text-transform: uppercase; font-weight: 600; }
        .stat-card-value { font-size: 16px; font-weight: 600; color: var(--text-primary); }

        .routes-section h3 {
            font-size: 13px;
            color: var(--text-secondary);
            text-transform: uppercase;
            letter-spacing: 1px;
            margin: 0 0 16px 0;
            font-weight: 700;
        }

        .route-card {
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid transparent;
        }

        .route-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .route-dest { font-weight: 700; font-size: 16px; }

        .transport-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 14px;
        }
        .transport-info { display: flex; gap: 10px; align-items: center; color: var(--text-secondary); }
        .transport-cost { font-size: 0.9em; opacity: 0.7; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #30363d;
            transition: .3s;
            border-radius: 34px;
            border: 1px solid #6e7681;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px; width: 18px;
            left: 2px; bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-green); border-color: var(--accent-green); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Portrait Mobile Optimization */
        @media (max-width: 600px) and (orientation: portrait) {
            #notification-area {
                top: 140px !important;
            }
            .legend-container {
                flex-direction: column !important;
                gap: 4px !important;
                padding: 6px 12px !important;
                top: 80px !important; /* Align with zoom/speed controls */
            }
            .legend-divider { display: none !important; }
        }

        /* Landscape Mobile Optimization */
        @media (max-height: 500px) and (orientation: landscape) {
            #notification-area {
                top: 60px !important; /* Below legend */
            }
            body, html { overflow: hidden !important; position: fixed; width: 100%; height: 100%; }
            
            #status-bar { 
                padding: 4px 12px;
                padding-right: max(12px, env(safe-area-inset-right)); /* Safe area */
                background: linear-gradient(180deg, rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.8) 100%);
                z-index: 15;
            }
            .stat-label { font-size: 9px; }
            .stat-value { font-size: 14px; }
            
            /* Hide bottom area wrapper */
            #bottom-area { display: none !important; }
            
            /* Positions are already good for landscape (corners), just tweak spacing */
            .zoom-controls { top: 60px; left: 10px; bottom: auto; }
            .fab-container { 
                top: 60px; 
                right: max(10px, env(safe-area-inset-right)); /* Safe area */
                bottom: auto; 
            }
            
            .legend-container { 
                top: 12px; /* Center top */
                bottom: auto;
                left: 50%; 
                transform: translateX(-50%); 
                padding: 6px 12px !important;
                background: rgba(22, 27, 34, 0.9) !important;
                flex-direction: row !important; /* Single row for landscape */
                gap: 12px !important;
            }
            .legend-divider { display: block !important; }
            
            #selection-sheet {
                position: fixed !important; /* Force fixed to viewport */
                width: 40% !important;
                min-width: 300px;
                top: 0 !important;
                height: 100vh !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                z-index: 1000;
                transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            }
            
            /* Default / Right Panel */
            #selection-sheet:not(.panel-left) {
                right: 0 !important;
                left: auto !important;
                border-left: 1px solid var(--panel-border);
                transform: translateX(100%);
            }
            #selection-sheet:not(.panel-left).active { transform: translateX(0); }

            /* Left Panel Override */
            #selection-sheet.panel-left {
                left: 0 !important;
                right: auto !important;
                border-right: 1px solid var(--panel-border);
                border-left: none;
                transform: translateX(-100%);
            }
            #selection-sheet.panel-left.active { transform: translateX(0); }
        }

        /* Overlay Screens */
        .overlay-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 2000;
            /* backdrop-filter: blur(10px); Removed for performance compatibility */
        }
        .overlay-screen h1 {
            font-size: 40px; margin-bottom: 10px; color: var(--text-primary);
            text-transform: uppercase; letter-spacing: 2px; text-align: center;
            line-height: 1.2;
        }
        .primary-btn {
            padding: 16px 48px; font-size: 18px; font-weight: bold;
            background: var(--accent-green); color: white; border: none; border-radius: 8px;
            cursor: pointer; transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 12px rgba(63, 185, 80, 0.3);
        }
        .primary-btn:hover { background: #4ac26b; }
        .primary-btn:active { transform: scale(0.95); }
        
        .final-score { margin-bottom: 24px; text-align: center; }
        .score-label { color: var(--text-secondary); font-size: 14px; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 4px; }
        .score-value { font-size: 36px; font-weight: 800; color: var(--text-primary); letter-spacing: -1px; }
    </style>
</head>
<body>

<div id="title-screen" class="overlay-screen">
    <h1>Global Supply<br>Chain Tycoon</h1>
    <p style="color:#8b949e; margin-bottom:40px; font-size:14px;">Manage routes, control inventory, and maximize profit.</p>
    <button class="primary-btn" onclick="startGame()">START GAME</button>
</div>

<div id="end-screen" class="overlay-screen" style="display:none;">
    <h1>GAME OVER</h1>
    <div class="final-score">
        <div class="score-label">Final Net Cash</div>
        <div class="score-value" id="final-cash">$0</div>
    </div>
    
    <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; margin-bottom:30px;">
        <div style="text-align:center;">
            <div class="score-label">Avg Freshness</div>
            <div class="score-value" style="font-size:24px;" id="final-fresh">-</div>
        </div>
        <div style="text-align:center;">
            <div class="score-label">Missed Sales</div>
            <div class="score-value" style="font-size:24px; color:var(--accent-red);" id="final-missed">-</div>
        </div>
        <div style="text-align:center;">
            <div class="score-label">Inv. Turnover</div>
            <div class="score-value" style="font-size:24px;" id="final-turnover">-</div>
        </div>
    </div>
    <button class="primary-btn" onclick="replayGame()">PLAY AGAIN</button>
</div>

<div id="game-container">
    <svg id="map-svg"></svg>
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div id="status-bar">
            <div class="stat-group" onclick="toggleDashboard()" style="cursor:pointer; pointer-events:auto;">
                <div class="stat-label">Net Cash <span style="font-size:10px; opacity:0.7;">‚ÑπÔ∏è</span></div>
                <div class="stat-value" id="cash-display">$100k</div>
            </div>
            <div class="stat-group" onclick="toggleHistory()" style="align-items: flex-end; cursor:pointer; pointer-events:auto;">
                <div class="stat-label">üìà Timeline</div>
                <div class="stat-value" id="time-display">Day 1</div>
            </div>
        </div>

        <div id="notification-area"></div>

        <div id="notification-area"></div>

        <!-- Controls moved out of bottom-area for independent positioning -->
        <div class="zoom-controls">
            <button class="fab-btn" onclick="adjustZoom(1.5)">+</button>
            <button class="fab-btn" onclick="adjustZoom(0.66)">-</button>
            <button class="fab-btn" style="font-size: 12px;" onclick="resetZoom()">1:1</button>
        </div>

        <div class="legend-container">
            <div class="legend-row">
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-red);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Raw</span></div>
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-yellow);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Factory</span></div>
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-green);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Market</span></div>
            </div>
            <div class="legend-divider"></div>
            <div class="legend-row">
                <div class="legend-item"><div style="width:10px; height:10px; background:var(--accent-blue);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Ship</span></div>
                <div class="legend-item"><div style="width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 9px solid #f0f6fc;"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Air</span></div>
            </div>
        </div>

        <div class="fab-container">
            <div class="fab-menu" id="speed-menu">
                <button class="fab-btn" onclick="cycleFastSpeed()">‚è©</button>
                <button class="fab-btn" onclick="setSpeed(1)">‚ñ∂</button>
                <button class="fab-btn active" onclick="setSpeed(0)">‚è∏</button>
            </div>
        </div>

        <div id="bottom-area">
            <!-- Empty now, kept for spacing if needed -->
        </div>

        <div id="selection-sheet">
            <div class="sheet-handle"></div>
            <div class="sheet-header">
                <h2 class="sheet-title" id="sheet-title">Location</h2>
                <button class="close-btn" onclick="closePanel()">√ó</button>
            </div>
            <div class="sheet-content">
                <div class="stats-grid" id="sheet-stats"></div>
                <div class="routes-section">
                    <h3>Distribution Channels</h3>
                    <div id="sheet-routes"></div>
                </div>
            </div>
        </div>

        <!-- REBUILT DASHBOARD MODAL -->
        <div id="dashboard-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0d1117; z-index:200; overflow-y:auto; padding:20px; box-sizing:border-box; pointer-events:auto; -webkit-overflow-scrolling:touch;">
            <div style="max-width:600px; margin:0 auto;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
                    <h2 style="margin:0; font-size:24px; color:#f0f6fc;">Global Performance</h2>
                    <button onclick="toggleDashboard()" style="background:none; border:none; color:#8b949e; font-size:28px; cursor:pointer;">√ó</button>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-label">Total Cash</div>
                        <div class="stat-card-value" id="dash-cash">$0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Global Inventory</div>
                        <div class="stat-card-value" id="dash-inv">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Active Ships</div>
                        <div class="stat-card-value" id="dash-ships" style="color:var(--accent-blue)">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Active Flights</div>
                        <div class="stat-card-value" id="dash-planes" style="color:var(--text-primary)">0</div>
                    </div>
                </div>
                <h3 style="margin-top:24px; color:#8b949e; font-size:14px; text-transform:uppercase;">Market Analysis</h3>
                <div id="dash-markets" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>
        </div>

        <!-- REBUILT HISTORY MODAL -->
        <div id="history-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:#0d1117; z-index:200; overflow-y:auto; padding:20px; box-sizing:border-box; pointer-events:auto; -webkit-overflow-scrolling:touch;">
            <div style="max-width:600px; margin:0 auto;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
                    <h2 style="margin:0; font-size:24px; color:#f0f6fc;">Growth Trends</h2>
                    <button onclick="toggleHistory()" style="background:none; border:none; color:#8b949e; font-size:28px; cursor:pointer;">√ó</button>
                </div>
                
                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border); margin-bottom:20px;">
                    <div class="stat-label">Net Cash Trend</div>
                    <div id="cash-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>

                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border); margin-bottom:20px;">
                    <div class="stat-label">Global Inventory Trend</div>
                    <div id="inv-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>

                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border);">
                    <div class="stat-label">Supply vs Demand Balance</div>
                    <div id="balance-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>
            </div>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>

<script>
// --- MAP DATA & WAYPOINTS ---
const WAYPOINTS = {
    panama: { coords: [-79.5, 9.0] },
    suez: { coords: [32.5, 30.0] },
    malacca: { coords: [102.0, 2.5] },
    capeGoodHope: { coords: [18.5, -34.5] },
    gibraltar: { coords: [-5.5, 36.0] },
    horn: { coords: [-67.0, -56.0] },
    hawaii: { coords: [-155, 20] },
    sriLanka: { coords: [80.5, 6.0] },
    taiwan: { coords: [121, 22] },
    southChinaSea: { coords: [113, 15] },
    westAfrica: { coords: [10.0, -5.0] },
    northAtlantic: { coords: [-40, 45] },
    midAtlantic: { coords: [-30, 10] },
    southAtlantic: { coords: [-25, -25] },
    guam: { coords: [145, 13] },
    redSea: { coords: [43.0, 13.0] },
    portugalCoast: { coords: [-10.0, 40.0] },
    dover: { coords: [0.0, 50.0] }
};

const NODES_DATA = [
    { id: 'brazil', name: 'Brazil', type: 'supply', coords: [-51, -14], production: 25, maxInventory: 3000 },
    { id: 'sa', name: 'South Africa', type: 'supply', coords: [25, -30], production: 6 },
    { id: 'congo', name: 'Congo', type: 'supply', coords: [21, -4], production: 18, maxInventory: 2500 },
    { id: 'china', name: 'China', type: 'make', coords: [121, 31], capacity: 2000, processRate: 25 },
    { id: 'india', name: 'India', type: 'make', coords: [73, 19], capacity: 1750, processRate: 20 },
    { id: 'vietnam', name: 'Vietnam', type: 'make', coords: [108, 14], capacity: 1500, processRate: 15 },
    { id: 'usa', name: 'USA', type: 'market', coords: [-95, 29], baseDemand: 25 },
    { id: 'germany', name: 'Germany', type: 'market', coords: [10, 51], baseDemand: 20 },
    { id: 'japan', name: 'Japan', type: 'market', coords: [138, 36], baseDemand: 15 }
];

const CONFIG = {
    startCash: 100000,
    colors: {
        supply: '#ef4444',
        make: '#f59e0b',
        market: '#10b981',
        seaPath: 'rgba(88, 166, 255, 0.3)',
        airPath: 'rgba(255, 255, 255, 0.15)',
        text: '#f0f6fc'
    },
    transport: {
        ship: { speed: 80, capacity: 500, costPerDispatch: 200, color: '#58a6ff' }, 
        air: { speed: 1000, capacity: 100, costPerDispatch: 800, color: '#f0f6fc' }
    },
    storageCostPerUnit: 0.1,
    salePrice: 20,
    upgradeCosts: {
        base: 5000,
        multiplier: 1.5
    }
};

let state = {
    cash: CONFIG.startCash,
    day: 1.0,
    lastIntegerDay: 1,
    timeAccumulator: 0,
    speed: 0,
    nodes: [],
    routes: [],
    units: [],
    particles: [],
    booms: [], // { nodeId, timeLeft, mult }
    history: { cash: [], inventory: [], days: [], demand: [], production: [] },
    totalSales: 0,
    totalLostSales: 0,
    selectedNodeId: null,
    lastTick: 0,
    transform: d3.zoomIdentity
};

const svg = d3.select("#map-svg");
const g = svg.append("g");
const canvas = document.getElementById("game-canvas");
const ctx = canvas.getContext("2d");
let projection, pathGenerator, zoomBehavior;
let width, height;

function init() {
    resize();
    window.addEventListener('resize', resize);

    zoomBehavior = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", (event) => {
            state.transform = event.transform;
            g.attr("transform", state.transform);
            render(); 
        });
    
    svg.call(zoomBehavior);
    
    d3.json("https://unpkg.com/world-atlas@2.0.2/countries-110m.json").then(worldData => {
        const countries = topojson.feature(worldData, worldData.objects.countries);
                    g.selectAll("path")
                        .data(countries.features)
                        .enter().append("path")
                        .attr("d", pathGenerator)
                        .attr("fill", "#1a1f26") 
                        .attr("stroke", "#30363d") 
                        .attr("stroke-width", 0.5);
        initGameLogic();
        setSpeed(0); // Sync UI with initial paused state
        
        // Force hide modals on init to prevent persistence bugs
        document.getElementById('dashboard-modal').style.display = 'none';
        document.getElementById('history-modal').style.display = 'none';
        
        requestAnimationFrame(gameLoop);
        render(); // Draw once
    });
}

function resize() {
    renderErrorShown = false;
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width * window.devicePixelRatio;
    canvas.height = height * window.devicePixelRatio;
    canvas.style.width = width + "px";
    canvas.style.height = height + "px";
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    
    const isPortrait = height > width;
    const translateY = isPortrait ? height * 0.4 : height / 1.8;

    projection = d3.geoNaturalEarth1()
        .scale(width / 6.5)
        .translate([width / 2, translateY]);
        
    pathGenerator = d3.geoPath().projection(projection);
    g.selectAll("path").attr("d", pathGenerator);
}

function initGameLogic() {
    state.nodes = NODES_DATA.map(n => ({
        ...n,
        inventory: 1000, 
        maxInventory: n.maxInventory || n.capacity || 1500,
        demand: 0,
        level: 1, 
        quality: 1.0, 
        unitCost: n.type === 'supply' ? (n.id === 'sa' ? 4.0 : 2.0) : (n.type === 'make' ? 6.0 : 8.0), // Init with standard costs
        phase: Math.random() * Math.PI * 2, 
        screenPos: projection(n.coords),
        alert: 0
    }));

    const addRoute = (from, to) => {
        state.routes.push(createRoute(state.nodes.find(n => n.id === from), state.nodes.find(n => n.id === to), 'ship'));
        state.routes.push(createRoute(state.nodes.find(n => n.id === from), state.nodes.find(n => n.id === to), 'air'));
    };

    const supply = state.nodes.filter(n => n.type === 'supply');
    const make = state.nodes.filter(n => n.type === 'make');
    const market = state.nodes.filter(n => n.type === 'market');

    supply.forEach(s => make.forEach(m => addRoute(s.id, m.id)));
    make.forEach(m => market.forEach(k => addRoute(m.id, k.id)));

    // Game starts Paused for route selection
    state.speed = 0;
    // Routes are inactive by default. User must toggle them.
}

function createRoute(fromNode, toNode, type) {
    let rawPoints = [];
    if (type === 'air') {
        rawPoints = [fromNode.coords, toNode.coords];
    } else {
        rawPoints = getShipPath(fromNode.coords, toNode.coords);
    }
    
    // High density for smooth interpolation
    const pathCoords = densifyPath(rawPoints, 0.005);
    
    // Calculate VISUAL distance (pixels) to ensure constant visual speed.
    // We use the global 'projection' which is set in resize() to the base scale.
    let totalVisualDist = 0;
    const segmentDists = [];
    
    for(let i=0; i<pathCoords.length-1; i++) {
        const p1 = projection(pathCoords[i]);
        const p2 = projection(pathCoords[i+1]);
        let d = 0;
        if (p1 && p2) {
            const dist = Math.hypot(p1[0]-p2[0], p1[1]-p2[1]);
            // Filter dateline wrap-around (large jumps)
            if (dist < width * 0.5) d = dist;
        }
        segmentDists.push(d);
        totalVisualDist += d;
    }

    // Create normalized visual stops [0, ..., 1]
    let acc = 0;
    const visualStops = [0];
    for (const d of segmentDists) {
        acc += d;
        visualStops.push(totalVisualDist > 0 ? acc / totalVisualDist : 1);
    }

    // Calculate time based on Visual Speed (pixels/sec)
    // Arbitrary scaling to match desired game pacing
    // Ship Speed 80 -> ~3.2 px/sec
    const speedPx = CONFIG.transport[type].speed * 0.04; 
    const travelTimeMs = (totalVisualDist / speedPx) * 1000;

    // Interval Calculation: DEMAND-BASED
    // Instead of relying on travel time (which favors short routes and starves long ones),
    // we calculate interval to match the destination's consumption rate.
    // Distance doesn't matter for frequency; throughput does.
    
    let targetDemand = 10; // Fallback
    if (toNode.type === 'market') targetDemand = toNode.baseDemand;
    else if (toNode.type === 'make') targetDemand = toNode.processRate;

    const capacity = CONFIG.transport[type].capacity;
    // Formula: Time to consume one shipment = Capacity / Demand.
    
    // For Air, we want less frequency as it's premium. 
    const typeFactor = type === 'ship' ? 2.5 : 8.0; 

    let interval = (capacity / Math.max(1, targetDemand)) * 1000 * typeFactor;
    
    // Clamp to reasonable bounds (0.5d to 30d)
    // 1 Day = 5000ms
    interval = Math.max(2500, Math.min(150000, interval));

    return {
        id: `${fromNode.id}-${toNode.id}-${type}`,
        from: fromNode.id, to: toNode.id, type, 
        active: false, timer: Math.random() * interval, 
        interval: interval,
        pathCoords: pathCoords,
        visualStops: visualStops,           
        totalVisualDistance: totalVisualDist 
    };
}

function densifyPath(points, resolution = 0.05) {
    if (points.length < 2) return points;
    let dense = [];
    for (let i = 0; i < points.length - 1; i++) {
        const start = points[i];
        const end = points[i+1];
        const dist = d3.geoDistance(start, end);
        const segments = Math.max(1, Math.ceil(dist / resolution));
        
        const interpolator = d3.geoInterpolate(start, end);
        for (let t = 0; t < 1; t += 1/segments) {
            dense.push(interpolator(t));
        }
    }
    dense.push(points[points.length - 1]);
    return dense;
}

function findRoute(fromId, toId, type) {
    return state.routes.find(r => r.from === fromId && r.to === toId && r.type === type);
}

function getShipPath(start, end) {
    const sLon = start[0], sLat = start[1];
    const eLon = end[0], eLat = end[1];
    
    const isAmericas = lon => lon < -30;
    const isEurope = (lon, lat) => lon >= -30 && lon < 50 && lat > 20;
    const isAfrica = (lon, lat) => lon >= -20 && lon < 60 && lat <= 20;
    const isAsia = lon => lon >= 60;

    const getR = (lon, lat) => {
        if (isAmericas(lon)) return 'americas';
        if (isEurope(lon, lat)) return 'europe';
        if (isAfrica(lon, lat)) return 'africa';
        if (isAsia(lon)) return 'asia';
        return 'unknown';
    };

    const sR = getR(sLon, sLat);
    const eR = getR(eLon, eLat);
    const pair = [sR, eR].sort().join('-'); 

    // Asia Internal (e.g. India <-> Japan/China)
    if (pair === 'asia-asia') {
        const isWest = lon => lon < 95; // India side
        const isEast = lon => lon >= 95; // East Asia side
        
        if ((isWest(sLon) && isEast(eLon)) || (isWest(eLon) && isEast(sLon))) {
            let route = [WAYPOINTS.sriLanka.coords, WAYPOINTS.malacca.coords];
            const eastPoint = sLon > eLon ? start : end;
            
            // East Asia bound leg
            if (eastPoint[0] > 105) {
                route.push(WAYPOINTS.southChinaSea.coords);
                if (eastPoint[1] > 20) route.push(WAYPOINTS.taiwan.coords);
            }
            
            if (sLon < eLon) return [start, ...route, end];
            return [start, ...route.reverse(), end];
        }
    }

    // 1. Americas <-> Asia
    if (pair === 'americas-asia') {
        // South America (Brazil) -> Asia via Cape (Eastbound)
        if (sLat < 0 || eLat < 0) {
             const asianPoint = sR === 'asia' ? start : end;
             const isFarEast = asianPoint[0] > 90; // Check if destination is East of India

             let route = isFarEast
                ? [WAYPOINTS.southAtlantic.coords, WAYPOINTS.capeGoodHope.coords, WAYPOINTS.sriLanka.coords, WAYPOINTS.malacca.coords]
                : [WAYPOINTS.southAtlantic.coords, WAYPOINTS.capeGoodHope.coords, WAYPOINTS.sriLanka.coords];
             
             if (isFarEast && asianPoint[0] > 105) {
                 route.push(WAYPOINTS.southChinaSea.coords);
                 if (asianPoint[1] > 20) route.push(WAYPOINTS.taiwan.coords);
             }

             if (sR === 'asia') return [start, ...route.reverse(), end];
             return [start, ...route, end];
        } 
        // North America -> Asia via Panama (Westbound)
        else {
             // Great Circle-ish route: Panama -> Hawaii -> Taiwan (Removed Guam to avoid southern detour)
             let route = [WAYPOINTS.panama.coords, WAYPOINTS.hawaii.coords, WAYPOINTS.taiwan.coords];
             
             // If Asia point is West (e.g. India), extend route via Malacca
             const asianPoint = sR === 'asia' ? start : end;
             if (asianPoint[0] < 90) {
                 route.push(WAYPOINTS.malacca.coords);
                 route.push(WAYPOINTS.sriLanka.coords);
             }

             if (sR === 'asia') return [start, ...route.reverse(), end];
             return [start, ...route, end];
        }
    }

    // 2. Americas <-> Europe
    if (pair === 'americas-europe') {
        // South America -> Europe (avoid North Atlantic WP)
        if (sLat < 0 || eLat < 0) {
            return [start, WAYPOINTS.midAtlantic.coords, end]; 
        }
        return [start, WAYPOINTS.northAtlantic.coords, end];
    }
    
    // 3. Asia <-> Europe
    if (pair === 'asia-europe') {
        const asianPoint = sR === 'asia' ? start : end;
        // Common European leg: Suez -> Gibraltar -> Portugal -> Dover
        const europeLeg = [WAYPOINTS.redSea.coords, WAYPOINTS.suez.coords, WAYPOINTS.gibraltar.coords, WAYPOINTS.portugalCoast.coords, WAYPOINTS.dover.coords];
        
        // If Asian point is West of Malacca (e.g. India), skip Malacca
        if (asianPoint[0] < 95) {
            // If West of Sri Lanka (e.g. Mumbai ~73), go direct to Red Sea
            let route = asianPoint[0] < 79 
                ? [...europeLeg] 
                : [WAYPOINTS.sriLanka.coords, ...europeLeg];

            if (sR === 'europe') return [start, ...route.reverse(), end];
            return [start, ...route, end];
        }
        
        let route = [WAYPOINTS.malacca.coords, WAYPOINTS.sriLanka.coords, ...europeLeg];
        if (asianPoint[0] > 105) {
            route.unshift(WAYPOINTS.southChinaSea.coords);
            if (asianPoint[1] > 20) route.unshift(WAYPOINTS.taiwan.coords);
        }
        if (sR === 'europe') return [start, ...route.reverse(), end];
        return [start, ...route, end];
    }

    // 4. Africa <-> Asia
    if (pair === 'africa-asia') {
        const asianPoint = sR === 'asia' ? start : end;
        const africanPoint = sR === 'africa' ? start : end;
        const isFarEast = asianPoint[0] > 90;

        // Basic route from Cape to Asia
        let route = isFarEast 
            ? [WAYPOINTS.capeGoodHope.coords, WAYPOINTS.sriLanka.coords, WAYPOINTS.malacca.coords]
            : [WAYPOINTS.capeGoodHope.coords, WAYPOINTS.sriLanka.coords];
        
        // If starting from West/Central Africa (e.g. Congo, lat > -30), go via West Coast first
        if (africanPoint[1] > -30) {
            route.unshift(WAYPOINTS.westAfrica.coords);
        }

        if (isFarEast && asianPoint[0] > 105) {
            route.push(WAYPOINTS.southChinaSea.coords);
            if (asianPoint[1] > 20) route.push(WAYPOINTS.taiwan.coords);
        }

        if (sR === 'asia') return [start, ...route.reverse(), end];
        return [start, ...route, end];
    }

    // 5. Africa <-> Europe
    if (pair === 'africa-europe') {
        let route = [WAYPOINTS.midAtlantic.coords, WAYPOINTS.gibraltar.coords];
        if (sR === 'europe') return [start, ...route.reverse(), end];
        return [start, ...route, end];
    }

    // 6. Brazil (Americas) <-> Africa
    if (pair === 'africa-americas') {
        return [start, end]; 
    }

    return [start, end];
}

function gameLoop(timestamp) {
    if (!state.lastTick) state.lastTick = timestamp;
    const dt = ((timestamp - state.lastTick) / 1000) * state.speed;
    state.lastTick = timestamp;
    if (dt > 0) { updateEconomy(dt); updateUnits(dt); updateParticles(dt); }
    render();
    requestAnimationFrame(gameLoop);
}

// Helper for comma-separated numbers
const formatInt = n => Math.floor(n).toLocaleString();

function updateEconomy(dt) {
    if (state.day >= 365) { endGame(); return; }

    // 1 Day = 5 seconds (at 1x speed) => 0.2 days/sec
    state.day += dt * 0.2;
    document.getElementById('time-display').innerText = `Day ${state.day.toFixed(1)}`; 
    
    // Record History on integer day change
    if (Math.floor(state.day) > state.lastIntegerDay) { 
        state.lastIntegerDay = Math.floor(state.day);
        
        // Record History
        const totalInv = state.nodes.reduce((a,n) => a + n.inventory, 0);
        const totalDemand = state.nodes.filter(n => n.type === 'market').reduce((a,n) => a + n.demand, 0);
        
        // Supply = Effective System Throughput
        // It's the bottleneck between Raw Material Production and Factory Processing Capacity.
        const totalRaw = state.nodes.filter(n => n.type === 'supply').reduce((a,n) => a + n.production, 0);
        const totalFactory = state.nodes.filter(n => n.type === 'make').reduce((a,n) => a + n.processRate, 0);
        const totalProd = Math.min(totalRaw, totalFactory);

        state.history.days.push(state.day);
        state.history.cash.push(state.cash);
        state.history.inventory.push(totalInv);
        state.history.demand.push(totalDemand);
        state.history.production.push(totalProd);
        
        // Keep last 50 points
        if (state.history.days.length > 50) {
            state.history.days.shift();
            state.history.cash.shift();
            state.history.inventory.shift();
            state.history.demand.shift();
            state.history.production.shift();
        }
    }
    
    // Manage Booms
    if (state.booms.length > 0) {
        state.booms.forEach(b => b.timeLeft -= dt);
        state.booms = state.booms.filter(b => b.timeLeft > 0);
    } else {
        // Chance to start a boom
        if (Math.random() < 0.05 * dt) { // Approx once every 20 real seconds
            const markets = state.nodes.filter(n => n.type === 'market');
            const target = markets[Math.floor(Math.random() * markets.length)];
            const mult = 2.5;
            state.booms.push({ nodeId: target.id, timeLeft: 15.0, mult: mult });
            // showNotification removed: UI updates in updateUI
            spawnParticle(projection(target.coords), "BOOM!", "#ffd700");
        }
    }

    state.nodes.forEach(node => {
        if (node.alert > 0) node.alert -= dt;

        const dailyToPerSec = 1.0 / 5.0; // 1 Day = 5 Seconds

        if (node.type === 'supply') {
            const prodAmount = node.production * dailyToPerSec * dt;
            const costAmount = prodAmount * (node.id === 'sa' ? 4.0 : 2.0);
            
            // Deduct Production Cost (Mining Expenses)
            state.cash -= costAmount;

            node.inventory = Math.min(node.maxInventory, node.inventory + prodAmount);
            
            // Base Production Cost (Raw Material Cost)
            const baseCost = node.id === 'sa' ? 4.0 : 2.0;

            // Slowly restore quality towards 1.0 and mix in base cost
            // We assume new production has unitCost = baseCost
            const newTotal = node.inventory; 
            const oldInv = Math.max(0, newTotal - prodAmount);
            
            node.quality = (oldInv * node.quality + prodAmount * 1.0) / newTotal;
            node.unitCost = (oldInv * node.unitCost + prodAmount * baseCost) / newTotal;
        }
        
        // Quality Decay for stored goods (Warehousing cost)
        // Markets decay faster (perishable goods)
        const decayRate = node.type === 'market' ? 0.005 : 0.001;
        if (node.inventory > 0) {
            node.quality = Math.max(0.1, node.quality - dt * decayRate);
        }

        if (node.type === 'market') {
            // Check for boom
            const boom = state.booms.find(b => b.nodeId === node.id);
            const boomMult = boom ? boom.mult : 1;

            node.demand = node.baseDemand * (1 + Math.sin(node.phase + Date.now()/2000) * 0.3) * boomMult;
            
            // FRESHNESS PRICING
            const qualityMult = 0.2 + 2.8 * Math.pow(node.quality, 2);
            const price = CONFIG.salePrice * qualityMult * boomMult;
            
            const sell = Math.min(node.inventory, node.demand * dailyToPerSec * dt);
            if (sell > 0) { 
                node.inventory -= sell; 
                state.cash += sell * price; 
                state.totalSales += sell; // Track Volume
                
                // Particle color based on Profit Margin & Freshness
                if (Math.random() < 0.05) {
                     const margin = price - node.unitCost;
                     let color = node.quality > 0.8 ? '#3fb950' : (node.quality > 0.5 ? '#dbab09' : '#f85149');
                     if (margin < 0) color = '#f85149'; // Loss is always red
                     
                     spawnParticle(projection(node.coords), `+$${Math.floor(sell*price)}`, color); 
                }
            }
            else if (node.demand > 0 && node.inventory < 1) {
                // Shortage tracking
                const missed = node.demand * dailyToPerSec * dt;
                state.totalLostSales += missed;
                
                if (Math.random() < 0.02) node.alert = 3.0;
            }
        }
    });
    
    state.routes.forEach(route => { 
        if (route.active) { 
            let tickRate = 1.0;
            const toNode = state.nodes.find(n => n.id === route.to);
            
            // Logic: Air routes work overtime during Booms or Crises
            if (route.type === 'air' && toNode.type === 'market') {
                const isBooming = state.booms.some(b => b.nodeId === toNode.id);
                const isCritical = toNode.inventory < toNode.maxInventory * 0.15;
                
                if (isBooming) tickRate = 20.0; // Instant response for booms
                else if (isCritical) tickRate = 5.0; // Fast response for shortages
            }

            route.timer += dt * 1000 * tickRate; 
            if (route.timer >= route.interval) { 
                route.timer = 0; 
                dispatchUnit(route); 
            } 
        } 
    });
    
    // THROTTLE UI UPDATES to ~5 FPS
    state.uiTimer = (state.uiTimer || 0) + dt;
    if (state.uiTimer > 0.2) {
        updateUI();
        updateDashboard();
        if (document.getElementById('history-modal').style.display !== 'none') renderHistoryCharts();
        state.uiTimer = 0;
    }
}

function dispatchUnit(route) {
    const from = state.nodes.find(n => n.id === route.from);
    const to = state.nodes.find(n => n.id === route.to);
    const cfg = CONFIG.transport[route.type];
    
    // PULL SYSTEM: Saturation Check
    // Count cargo already en route to the destination
    const incomingCargo = state.units
        .filter(u => {
             const r = state.routes.find(r => r.id === u.routeId);
             return r && r.to === to.id;
        })
        .reduce((sum, u) => sum + u.cargo, 0);

    // Prevent oversupply: If Inventory + Incoming > Max, don't send more.
    if (to.inventory + incomingCargo >= to.maxInventory) {
        return;
    }

    // Partial Shipment Logic: Send whatever is available if it's worth it (> 10 units)
    // Don't wait for full capacity if destination is needy.
    let amount = Math.min(cfg.capacity, from.inventory);
    
    // Cost Check & Min Amount
    if (amount > 10 && state.cash >= cfg.costPerDispatch) {
        from.inventory -= amount; 
        state.cash -= cfg.costPerDispatch;
        
        // Calculate Cost Basis
        const transportCostPerUnit = cfg.costPerDispatch / amount;
        const totalUnitCost = from.unitCost + transportCostPerUnit;

        state.units.push({ 
            routeId: route.id, 
            type: route.type, 
            pathCoords: route.pathCoords, 
            progress: 0, 
            cargo: amount,
            quality: from.quality,
            unitCost: totalUnitCost
        });
    }
}

function updateUnits(dt) {
    for (let i = state.units.length - 1; i >= 0; i--) {
        const u = state.units[i];
        const route = state.routes.find(r => r.id === u.routeId);
        
        // Visual Speed Mode
        // Ship Speed 80 -> 3.2px/sec
        // Air Speed 1000 -> 40px/sec
        const speedPx = CONFIG.transport[u.type].speed * 0.04;
        
        // progress += (PixelsPerSec * dt) / TotalPixels
        const dist = Math.max(1, route.totalVisualDistance);
        u.progress += (speedPx * dt) / dist;

        // Freshness Decay in Transit
        // Ships take longer, so decay accumulates more. Air is fast.
        // Base decay rate: 0.001 per second
        u.quality = Math.max(0.1, u.quality - dt * 0.001);

        if (u.progress >= 1) {
            const dest = state.nodes.find(n => n.id === route.to);
            
            // Add Manufacturing Value/Cost if destination is a factory
            // This represents the cost added to transform Raw -> Product
            if (dest.type === 'make') {
                const makeCost = dest.id === 'china' ? 3.0 : (dest.id === 'vietnam' ? 2.0 : 4.0);
                u.unitCost += makeCost;
                state.cash -= u.cargo * makeCost; // Deduct Manufacturing OpEx
            }

            // Weighted Average Mixing: Quality AND Cost
            const totalStock = dest.inventory + u.cargo;
            if (totalStock > 0) {
                dest.quality = ((dest.inventory * dest.quality) + (u.cargo * u.quality)) / totalStock;
                dest.unitCost = ((dest.inventory * dest.unitCost) + (u.cargo * u.unitCost)) / totalStock;
            }
            
            dest.inventory += u.cargo;
            state.units.splice(i, 1);
        }
    }
}

function updateParticles(dt) {
    for (let i = state.particles.length - 1; i >= 0; i--) {
        state.particles[i].life -= dt; state.particles[i].y -= 10 * dt;
        if (state.particles[i].life <= 0) state.particles.splice(i, 1);
    }
}

function spawnParticle(pos, text, color) { state.particles.push({ x: pos[0], y: pos[1] - 10, text, color, life: 1.5 }); }

let renderErrorShown = false;
function render() {
    try {
        ctx.clearRect(0, 0, width, height);
        
        ctx.save();
        ctx.translate(state.transform.x, state.transform.y);
        ctx.scale(state.transform.k, state.transform.k);
        
        // 1. Draw Routes using d3.geoPath for correct dateline clipping
        state.routes.forEach(r => {
            const hasUnits = state.units.some(u => u.routeId === r.id);
            if (!r.active && !hasUnits) return;
            
            ctx.beginPath();
            pathGenerator.context(ctx)({type: "LineString", coordinates: r.pathCoords});
            
            // If inactive but has units, render with slightly lower opacity to indicate "shutting down"
            const baseColor = r.type === 'air' ? CONFIG.colors.airPath : CONFIG.colors.seaPath;
            ctx.strokeStyle = (!r.active && hasUnits) ? baseColor.replace('0.3', '0.1').replace('0.15', '0.05') : baseColor;
            // Actually, replace on rgba string might be brittle if format changes, but CONFIG uses specific strings.
            // CONFIG.seaPath: 'rgba(88, 166, 255, 0.3)'
            // CONFIG.airPath: 'rgba(255, 255, 255, 0.15)'
            // Let's just use the base color for now to satisfy "don't erase".
            ctx.strokeStyle = baseColor;

            ctx.lineWidth = (r.type === 'air' ? 1.5 : 2) / state.transform.k;
            if (r.type === 'air') ctx.setLineDash([4/state.transform.k, 6/state.transform.k]);
            ctx.stroke(); 
            ctx.setLineDash([]);
            
            pathGenerator.context(null); // Reset context
        });

        // 2. Draw Units with correct interpolation
        state.units.forEach(u => {
            const route = state.routes.find(r => r.id === u.routeId);
            if (!route || !route.visualStops || route.visualStops.length < 2) return;

            // Use visual stops for constant visual speed interpolation
            const stops = route.visualStops;
            
            // Find segment: stops[i] <= u.progress <= stops[i+1]
            let idx = stops.findIndex(s => s > u.progress);
            if (idx === -1) idx = stops.length - 1;
            idx = Math.max(1, idx) - 1;
            
            // Safety check for index bounds
            if (idx < 0 || idx >= route.pathCoords.length - 1) return;

            const startP = stops[idx];
            const endP = stops[idx+1];
            
            if (startP === undefined || endP === undefined) return;

            const range = endP - startP;
            
            // Normalize t within the segment (0..1)
            const t = range > 0 ? (u.progress - startP) / range : 0;
            
            const interpolator = d3.geoInterpolate(route.pathCoords[idx], route.pathCoords[idx+1]);
            const pos = interpolator(t);
            const p = projection(pos);
                
            if (p) { // Check if point is projected (not clipped)
                const [x, y] = p;
                ctx.fillStyle = u.type === 'ship' ? CONFIG.transport.ship.color : CONFIG.transport.air.color;
                ctx.beginPath();
                if (u.type === 'ship') {
                    const s = 4/state.transform.k;
                    ctx.rect(x - s, y - s, s * 2, s * 2);
                } else {
                    const s = 5/state.transform.k;
                    ctx.moveTo(x, y - s);
                    ctx.lineTo(x + s, y + s);
                    ctx.lineTo(x - s, y + s);
                }
                ctx.fill();
            }
        });

        state.nodes.forEach(n => {
            const [x, y] = projection(n.coords), isSel = state.selectedNodeId === n.id, r = (isSel ? 14 : 9) / state.transform.k;
            
            // Boom Effect
            const boom = state.booms.find(b => b.nodeId === n.id);
            if (boom) {
                 const t = (Date.now() / 300) % 1;
                 ctx.beginPath();
                 ctx.arc(x, y, r + (30 * t)/state.transform.k, 0, Math.PI * 2);
                 ctx.strokeStyle = `rgba(255, 215, 0, ${1-t})`; 
                 ctx.lineWidth = 4/state.transform.k; 
                 ctx.stroke();
            }

            if (n.alert > 0) {
                const t = (Date.now() / 800) % 1;
                ctx.beginPath(); 
                ctx.arc(x, y, r + (20 * t)/state.transform.k, 0, Math.PI * 2); 
                ctx.fillStyle = `rgba(248, 81, 73, ${0.4 * (1-t)})`; ctx.fill();
                ctx.strokeStyle = `rgba(248, 81, 73, ${1-t})`; ctx.lineWidth = 2/state.transform.k; ctx.stroke();
            }

            // Draw Node Circle
            ctx.beginPath(); ctx.arc(x, y, r, 0, Math.PI * 2); ctx.fillStyle = CONFIG.colors[n.type]; ctx.fill();
            
            // Draw Selection Ring (Simpler logic)
            if (isSel) {
                 ctx.strokeStyle = '#fff'; 
                 ctx.lineWidth = 3/state.transform.k; 
                 ctx.stroke();
            } else {
                 ctx.strokeStyle = '#161b22'; 
                 ctx.lineWidth = 2/state.transform.k; 
                 ctx.stroke();
            }

            const bw = 32/state.transform.k, bh = 5/state.transform.k, pct = Math.min(1, n.inventory / n.maxInventory);
            ctx.fillStyle = "rgba(22, 27, 34, 0.8)"; ctx.fillRect(x - bw/2, y + r + 2/state.transform.k, bw, bh);
            ctx.fillStyle = pct < 0.2 ? CONFIG.colors.supply : CONFIG.colors.market; ctx.fillRect(x - bw/2, y + r + 2/state.transform.k, bw * pct, bh);
        });

        state.particles.forEach(p => { ctx.globalAlpha = Math.max(0, p.life); ctx.font = `bold ${14/state.transform.k}px Inter`; ctx.fillStyle = p.color; ctx.fillText(p.text, p.x, p.y); ctx.globalAlpha = 1; });
        ctx.restore();
    } catch (e) {
        if (!renderErrorShown) {
            console.error(e);
            // Notification removed
            renderErrorShown = true;
        }
    }
}

function updateUI() {
    const fmt = n => n >= 1e6 ? '$' + (n/1e6).toFixed(1) + 'M' : (n >= 1e3 ? '$' + (n/1e3).toFixed(0) + 'k' : '$' + Math.floor(n));
    document.getElementById('cash-display').innerText = fmt(state.cash);
    if (state.selectedNodeId) updateSheetStats(state.nodes.find(n => n.id === state.selectedNodeId));

    // Update Boom Notifications (Persistent)
    const area = document.getElementById('notification-area');
    if (state.booms.length === 0) {
        area.innerHTML = '';
    } else {
        area.innerHTML = state.booms.map(b => {
            const node = state.nodes.find(n => n.id === b.nodeId);
            return `<div class="toast info" style="opacity:1; transform:none; animation:none; border-bottom: 2px solid #ffd700; width: fit-content;">
                <span class="toast-icon">üî•</span><span><strong>${node.name}</strong>:x${b.mult} Dem/Price (${Math.ceil(b.timeLeft)}s)</span>
            </div>`;
        }).join('');
    }
}

d3.select("#map-svg").on("click", (event) => {
    const [mx, my] = d3.pointer(event);
    const tx = (mx - state.transform.x) / state.transform.k, ty = (my - state.transform.y) / state.transform.k;
    const clicked = state.nodes.find(n => { const [nx, ny] = projection(n.coords); return Math.hypot(nx - tx, ny - ty) < 25/state.transform.k; });
    if (clicked) openSheet(clicked); else closePanel();
});

function openSheet(node) {
    state.selectedNodeId = node.id;
    const s = document.getElementById('selection-sheet');
    document.getElementById('sheet-title').innerText = node.name;
    document.getElementById('sheet-title').style.color = CONFIG.colors[node.type];
    
    // Dynamic Positioning for Landscape
    if (window.innerWidth > window.innerHeight && window.innerHeight <= 500) {
        // Calculate screen pos
        const [nx, ny] = projection(node.coords);
        const tx = nx * state.transform.k + state.transform.x;
        
        s.classList.remove('panel-left', 'panel-right');
        if (tx < window.innerWidth / 2) {
            s.classList.add('panel-right'); // Node left -> Panel Right
        } else {
            s.classList.add('panel-left'); // Node right -> Panel Left
        }
        s.style.minHeight = '100%'; // Full height side panel
        s.style.maxHeight = '100%';
    } else {
        s.classList.remove('panel-left', 'panel-right');
        // Portrait / Default
        s.style.minHeight = '50vh'; // Ensure it covers at least half screen
        s.style.maxHeight = '85vh';
    }

    updateSheetStats(node); 
    renderSheetRoutes(node);
    s.classList.add('active');
}

function updateSheetStats(n) {
    const container = document.getElementById('sheet-stats');
    const cost = Math.floor(CONFIG.upgradeCosts.base * Math.pow(CONFIG.upgradeCosts.multiplier, n.level - 1));
    const canAfford = state.cash >= cost;
    
    // Check if we need to full render (initial open) or just update values
    // We use a data attribute to track the current node ID to force redraw on switch
    if (container.getAttribute('data-node-id') !== n.id) {
        container.setAttribute('data-node-id', n.id);
        
        let label = "";
        if (n.type === 'supply') label = "Production";
        else if (n.type === 'make') label = "Throughput";
        else if (n.type === 'market') label = "Marketing";

        let h = `<div class="stat-card" style="grid-column: span 2; display:flex; justify-content:space-between; align-items:center; padding: 10px 16px;" id="upgrade-card">
                <div style="display:flex; flex-direction:column;">
                    <div class="stat-card-label">${label}: Lv <span id="stat-lvl">${n.level}</span></div>
                    <div class="stat-card-value" id="stat-cost">$${(cost/1000).toFixed(1)}k</div>
                </div>
                <button id="btn-upgrade" onclick="upgradeNode('${n.id}')" style="border:none; padding:8px 16px; border-radius:6px; font-weight:bold; white-space:nowrap; margin-left:10px;">UPGRADE</button>
              </div>`;

        h += `<div class="stat-card"><div class="stat-card-label" title="Includes variable transport costs. Fill vehicles to reduce this!">Avg. Unit Cost <span style="cursor:help; opacity:0.7;">‚ÑπÔ∏è</span></div><div class="stat-card-value">$${n.unitCost.toFixed(2)}</div></div>`;
        h += `<div class="stat-card"><div class="stat-card-label">Stock Level</div><div class="stat-card-value"><span id="stat-stock">${Math.floor(n.inventory)}</span> <span style="font-size:0.7em; color:#8b949e">/ <span id="stat-max">${Math.floor(n.maxInventory)}</span></span></div></div>`;
        
        if (n.type === 'market') {
            h += `<div class="stat-card"><div class="stat-card-label">Product Freshness</div><div class="stat-card-value"><span id="stat-fresh-val">0%</span> <span id="stat-fresh-text" style="font-size:12px; opacity:0.8">-</span></div></div>`;
            h += `<div class="stat-card"><div class="stat-card-label">Current Price</div><div class="stat-card-value" style="color:var(--accent-green)"><span id="stat-price-val">$0</span> <span style="font-size:12px; color:var(--text-secondary)">/ unit</span></div></div>`;
            h += `<div class="stat-card"><div class="stat-card-label">Market Demand</div><div class="stat-card-value" style="color:var(--accent-green)"><span id="stat-rate">${n.demand.toFixed(1)}</span> /d</div></div>`;
        }
        else if (n.type === 'supply') h += `<div class="stat-card"><div class="stat-card-label">Production</div><div class="stat-card-value" style="color:var(--accent-red)"><span id="stat-rate">${n.production.toFixed(1)}</span> /d</div></div>`;
        else if (n.type === 'make') h += `<div class="stat-card"><div class="stat-card-label">Throughput</div><div class="stat-card-value" style="color:var(--accent-yellow)"><span id="stat-rate">${n.processRate.toFixed(1)}</span> /d</div></div>`;
        
        container.innerHTML = h;
    }

    // Dynamic Updates (Text & Style only) - Preserves Event Listeners
    document.getElementById('stat-lvl').innerText = n.level;
    document.getElementById('stat-cost').innerText = '$' + (cost/1000).toFixed(1) + 'k';
    document.getElementById('stat-stock').innerText = Math.floor(n.inventory);
    document.getElementById('stat-max').innerText = Math.floor(n.maxInventory);
    
    // Rate update
    const rateEl = document.getElementById('stat-rate');
    if (rateEl) rateEl.innerText = (n.type==='market'?n.demand:n.type==='supply'?n.production:n.processRate).toFixed(1);

    // Market Specific Dynamic Updates
    if (n.type === 'market') {
        const boom = state.booms.find(b => b.nodeId === n.id);
        const boomMult = boom ? boom.mult : 1;
        const qualityMult = 0.2 + 2.8 * Math.pow(n.quality, 2);
        const currentPrice = CONFIG.salePrice * qualityMult * boomMult;

        const freshVal = document.getElementById('stat-fresh-val');
        const freshText = document.getElementById('stat-fresh-text');
        const priceVal = document.getElementById('stat-price-val');
        
        // Logic: Out of stock -> Hide freshness/price or show empty state
        // Else: Color logic
        if (n.inventory < 1) {
            if (freshVal) {
                freshVal.innerText = "-";
                freshVal.parentElement.style.color = 'var(--text-secondary)';
            }
            if (freshText) freshText.innerText = "OUT OF STOCK";
            if (priceVal) priceVal.innerText = "-";
        } else {
            const q = n.quality;
            // > 0.8: Green (Premium)
            // 0.4 - 0.8: Yellow (Fresh/Normal)
            // <= 0.4: Red (Stale)
            const qColor = q > 0.8 ? '#3fb950' : (q > 0.4 ? '#dbab09' : '#f85149');
            const qText = q > 0.85 ? 'PREMIUM' : (q > 0.6 ? 'FRESH' : (q > 0.4 ? 'NORMAL' : 'STALE'));
            
            if (freshVal) {
                freshVal.innerText = (q*100).toFixed(0) + '%';
                freshVal.parentElement.style.color = qColor;
            }
            if (freshText) freshText.innerText = qText;
            if (priceVal) priceVal.innerText = '$' + currentPrice.toFixed(1);
        }
    }

    const btn = document.getElementById('btn-upgrade');
    const card = document.getElementById('upgrade-card');
    
    // Update button style without replacing element
    btn.style.background = canAfford ? 'var(--accent-green)' : '#30363d';
    btn.style.color = 'white';
    btn.style.cursor = canAfford ? 'pointer' : 'not-allowed';
    btn.style.opacity = canAfford ? 1 : 0.5;
    
    card.style.background = canAfford ? 'rgba(63, 185, 80, 0.15)' : 'rgba(255,255,255,0.05)';
    card.style.borderColor = canAfford ? 'var(--accent-green)' : 'transparent';
    card.style.borderWidth = '1px';
    card.style.borderStyle = 'solid';
}

function renderSheetRoutes(n) {
    const section = document.querySelector('.routes-section');
    if (n.type === 'market') {
        section.style.display = 'none';
        return;
    }
    section.style.display = 'block';

    const c = document.getElementById('sheet-routes'), out = state.routes.filter(r => r.from === n.id);
    if (!out.length) { c.innerHTML = '<div style="color:var(--text-secondary); font-style:italic;">No outgoing routes.</div>'; return; }
    c.innerHTML = '';
    const iconAir = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 20 21 12 17 4 21 12 2"></polygon></svg>';
    const iconShip = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 21c.6.5 1.2 1 2.5 1 2.3 0 2.8-1 5-1 2.3 0 2.8 1 5 1 2.3 0 2.8-1 5-1 2.3 0 2.8 1 5 1 1.2 0 1.9-.5 2.5-1M2 21v-8c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v8M12 11V3L9 6M12 3l3 3"/></svg>';

    [...new Set(out.map(r => r.to))].forEach(tid => {
        const tn = state.nodes.find(x => x.id === tid), air = out.find(r => r.to === tid && r.type === 'air'), ship = out.find(r => r.to === tid && r.type === 'ship');
        c.innerHTML += `<div class="route-card"><div class="route-row"><span class="route-dest">To ${tn.name}</span></div>${renderOpt(air, 'Air', iconAir, '$1.5k')}${renderOpt(ship, 'Sea', iconShip, '$200')}</div>`;
    });
}

function renderOpt(r, l, i, c) {
    if (!r) return '';
    // frequency in Game Days. Convert r.interval (ms) to Days.
    // 1 Day = 5000ms. So days = interval / 5000.
    const days = (r.interval / 5000).toFixed(1);
    
    return `<div class="transport-option" style="flex-direction:column; align-items:flex-start; gap:8px;">
        <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <div class="transport-info"><span>${i}</span><span style="font-weight:500;">${l}</span><span class="transport-cost">${c}</span></div>
            <label class="switch" onclick="event.stopPropagation()"><input type="checkbox" ${r.active?'checked':''} onchange="toggleRoute('${r.id}')"><span class="slider"></span></label>
        </div>
        <div style="width:100%; display:${r.active?'flex':'none'}; align-items:center; gap:8px;" id="ctrl-${r.id}">
            <span style="font-size:11px; color:var(--text-secondary); white-space:nowrap;">Interval: <span id="val-${r.id}">${days}</span>d</span>
            <input type="range" min="0.5" max="30" step="0.5" value="${days}" style="flex:1" oninput="updateInterval('${r.id}', this.value)">
        </div>
    </div>`;
}

window.updateInterval = (id, val) => {
    const r = state.routes.find(x => x.id === id);
    if (r) {
        r.interval = val * 5000; // Convert Days -> MS (1 Day = 5s)
        document.getElementById(`val-${id}`).innerText = val;
    }
};

window.toggleRoute = id => { 
    const r = state.routes.find(x => x.id === id); 
    if(r) {
        r.active = !r.active;
        const ctrl = document.getElementById(`ctrl-${id}`);
        if(ctrl) ctrl.style.display = r.active ? 'flex' : 'none';
    } 
};
window.toggleSpeedMenu = () => document.getElementById('speed-menu').classList.toggle('open');

window.setSpeed = val => { 
    const v = Number(val);
    state.speed = v; 
    const btns = document.querySelectorAll('.fab-menu .fab-btn');
    // Button order in HTML: [Fast, Play, Pause] (indices 0, 1, 2)
    // Wait, check HTML order: Fast is first child?
    // HTML: Fast(0), Play(1), Pause(2)
    
    btns[0].classList.toggle('active', v >= 3);
    btns[1].classList.toggle('active', v === 1);
    btns[2].classList.toggle('active', v === 0);
    
    if (v >= 3) btns[0].innerText = `‚è© x${v}`;
    else btns[0].innerText = '‚è©';
};

window.cycleFastSpeed = () => {
    if (state.speed < 3) setSpeed(3);
    else if (state.speed === 3) setSpeed(10);
    else if (state.speed === 10) setSpeed(50);
    else setSpeed(3);
};

window.adjustZoom = f => svg.transition().call(zoomBehavior.scaleBy, f);
window.resetZoom = () => svg.transition().call(zoomBehavior.transform, d3.zoomIdentity);
window.closePanel = () => { document.getElementById('selection-sheet').classList.remove('active'); state.selectedNodeId = null; renderErrorShown = false; render(); };

window.toggleDashboard = () => {
    const dash = document.getElementById('dashboard-modal');
    const hist = document.getElementById('history-modal');
    
    // Close history
    hist.style.display = 'none';
    
    // Toggle dashboard
    if (dash.style.display === 'none' || !dash.style.display) {
        dash.style.display = 'block';
        updateDashboard();
    } else {
        dash.style.display = 'none';
    }
};

window.toggleHistory = () => {
    const dash = document.getElementById('dashboard-modal');
    const hist = document.getElementById('history-modal');
    
    // Close dashboard
    dash.style.display = 'none';
    
    // Toggle history
    if (hist.style.display === 'none' || !hist.style.display) {
        hist.style.display = 'block';
        renderHistoryCharts();
    } else {
        hist.style.display = 'none';
    }
};

function updateDashboard() {
    if (document.getElementById('dashboard-modal').style.display === 'none') return;

    // KPI Updates
    document.getElementById('dash-cash').innerText = '$' + formatInt(state.cash);
    document.getElementById('dash-inv').innerText = formatInt(state.nodes.reduce((a,n) => a + n.inventory, 0));
    document.getElementById('dash-ships').innerText = formatInt(state.units.filter(u => u.type === 'ship').length);
    document.getElementById('dash-planes').innerText = formatInt(state.units.filter(u => u.type === 'air').length);

    const markets = state.nodes.filter(n => n.type === 'market');
    const mList = document.getElementById('dash-markets');
    
    // Header
    let html = `
        <div style="display:grid; grid-template-columns: 1fr 1.5fr 1fr 1fr; gap:8px; padding:8px 12px; font-size:12px; color:var(--text-secondary); text-transform:uppercase; font-weight:700;">
            <div>Market</div>
            <div>Stock / Cap</div>
            <div>Demand</div>
            <div>Status</div>
        </div>
    `;

    // Rows
    html += markets.map(m => {
        const fillRate = m.inventory / m.maxInventory;
        let status = '<span style="color:var(--accent-green)">Healthy</span>';
        if (fillRate < 0.1) status = '<span style="color:var(--accent-red)">Starving</span>';
        else if (fillRate > 0.9) status = '<span style="color:var(--accent-yellow)">Full</span>';
        else if (m.demand > m.inventory && m.inventory > 0) status = '<span style="color:var(--accent-yellow)">Draining</span>';

        return `
        <div style="background:rgba(255,255,255,0.03); padding:10px 12px; border-radius:8px; display:grid; grid-template-columns: 1fr 1.5fr 1fr 1fr; gap:8px; align-items:center; border:1px solid var(--panel-border); margin-bottom:6px;">
            <span style="font-weight:bold;">${m.name}</span>
            <span style="font-family:monospace; color:${fillRate<0.2?'var(--accent-red)':'var(--text-primary)'}">
                ${formatInt(m.inventory)} <span style="color:var(--text-secondary)">/ ${formatInt(m.maxInventory)}</span>
            </span>
            <span style="font-family:monospace;">${m.demand.toFixed(1)}/d</span>
            <span style="font-size:13px;">${status}</span>
        </div>`;
    }).join('');
    
    mList.innerHTML = html;
}

function renderHistoryCharts() {
    if (state.history.days.length < 2) {
        document.getElementById('cash-chart').innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-secondary);">Waiting for more data...</div>';
        document.getElementById('inv-chart').innerHTML = '';
        return;
    }

    const draw = (containerId, data, color, unit = "") => {
        const container = document.getElementById(containerId);
        container.innerHTML = '';
        const margin = {top: 20, right: 10, bottom: 25, left: 50};
        const w = container.clientWidth - margin.left - margin.right;
        const h = container.clientHeight - margin.top - margin.bottom;
        
        const svg = d3.select(container).append("svg")
            .attr("width", w + margin.left + margin.right)
            .attr("height", h + margin.top + margin.bottom)
            .append("g")
            .attr("transform", `translate(${margin.left},${margin.top})`);
        
        const x = d3.scaleLinear().domain(d3.extent(state.history.days)).range([0, w]);
        const y = d3.scaleLinear().domain([d3.min(data) * 0.9, d3.max(data) * 1.1]).range([h, 0]);
        
        // Add Y Unit Label
        svg.append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", -margin.left + 12)
            .attr("x", -h / 2)
            .attr("text-anchor", "middle")
            .style("font-size", "10px")
            .attr("fill", "var(--text-secondary)")
            .text(unit);

        // Add Axes
        svg.append("g")
            .attr("transform", `translate(0,${h})`)
            .call(d3.axisBottom(x).ticks(5).tickFormat(d => `Day ${d}`))
            .attr("color", "#8b949e");
            
        svg.append("g")
            .call(d3.axisLeft(y).ticks(5).tickFormat(d => d >= 1000 ? `${(d/1000).toFixed(0)}k` : d))
            .attr("color", "#8b949e");
        
        const line = d3.line()
            .x((d, i) => x(state.history.days[i]))
            .y(d => y(d))
            .curve(d3.curveMonotoneX);
            
        svg.append("path")
            .datum(data)
            .attr("fill", "none")
            .attr("stroke", color)
            .attr("stroke-width", 2)
            .attr("d", line);
            
        // Area fill
        const area = d3.area()
            .x((d, i) => x(state.history.days[i]))
            .y0(h)
            .y1(d => y(d))
            .curve(d3.curveMonotoneX);
            
        svg.append("path")
            .datum(data)
            .attr("fill", color)
            .attr("opacity", 0.1)
            .attr("d", area);
    };

    draw('cash-chart', state.history.cash, 'var(--accent-blue)', "Amount ($)");
    draw('inv-chart', state.history.inventory, 'var(--accent-green)', "Quantity");
    
    // Draw Balance Chart (Multi-line)
    const container = document.getElementById('balance-chart');
    container.innerHTML = '';
    const margin = {top: 20, right: 10, bottom: 25, left: 50};
    const w = container.clientWidth - margin.left - margin.right;
    const h = container.clientHeight - margin.top - margin.bottom;
    
    const svg = d3.select(container).append("svg")
        .attr("width", w + margin.left + margin.right)
        .attr("height", h + margin.top + margin.bottom)
        .append("g")
        .attr("transform", `translate(${margin.left},${margin.top})`);
        
    const dataDem = state.history.demand;
    const dataProd = state.history.production;
    const allVals = [...dataDem, ...dataProd];
    
    const x = d3.scaleLinear().domain(d3.extent(state.history.days)).range([0, w]);
    const y = d3.scaleLinear().domain([d3.min(allVals) * 0.9, d3.max(allVals) * 1.1]).range([h, 0]);
    
    // Grid
    svg.append("g")
        .attr("class", "grid")
        .attr("opacity", 0.1)
        .call(d3.axisLeft(y).tickSize(-w).tickFormat(""));

    svg.append("g")
        .attr("transform", `translate(0,${h})`)
        .call(d3.axisBottom(x).ticks(5).tickFormat(d => `Day ${d}`))
        .attr("color", "#8b949e");
        
    svg.append("g")
        .call(d3.axisLeft(y).ticks(5).tickFormat(d => d >= 1000 ? `${(d/1000).toFixed(1)}k` : d))
        .attr("color", "#8b949e");

    // Y Unit Label
    svg.append("text")
        .attr("transform", "rotate(-90)")
        .attr("y", -margin.left + 12)
        .attr("x", -h / 2)
        .attr("text-anchor", "middle")
        .style("font-size", "10px")
        .attr("fill", "var(--text-secondary)")
        .text("Rate (/s)");

    const line = d3.line().x((d, i) => x(state.history.days[i])).y(d => y(d)).curve(d3.curveMonotoneX);
    
    // Demand Line (Red)
    svg.append("path").datum(dataDem).attr("fill","none").attr("stroke","var(--accent-red)").attr("stroke-width",2).attr("d",line);
    // Prod Line (Blue)
    svg.append("path").datum(dataProd).attr("fill","none").attr("stroke","var(--accent-blue)").attr("stroke-width",2).attr("stroke-dasharray","4").attr("d",line);
    
    // Legend
    svg.append("text").attr("x", 10).attr("y", -5).text("Demand").attr("fill", "var(--accent-red)").style("font-size", "10px");
    svg.append("text").attr("x", 60).attr("y", -5).text("Supply").attr("fill", "var(--accent-blue)").style("font-size", "10px");
}

window.upgradeNode = (id) => {
    const node = state.nodes.find(n => n.id === id);
    if (!node) return;
    
    const cost = Math.floor(CONFIG.upgradeCosts.base * Math.pow(CONFIG.upgradeCosts.multiplier, node.level - 1));
    
    if (state.cash >= cost) {
        state.cash -= cost;
        node.level++;
        
        // Upgrade effects based on type
        if (node.type === 'supply') {
            node.production *= 1.2; // +20% production
            node.maxInventory *= 1.2;
        } else if (node.type === 'make') {
            node.capacity *= 1.2; // +20% throughput
            node.processRate *= 1.2;
            node.maxInventory *= 1.2;

            // Update incoming routes to match new processRate
            state.routes.filter(r => r.to === node.id).forEach(r => {
                const typeFactor = r.type === 'ship' ? 2.5 : 8.0; 
                const cap = CONFIG.transport[r.type].capacity;
                let newInt = (cap / Math.max(1, node.processRate)) * 1000 * typeFactor;
                r.interval = Math.max(r.type === 'ship' ? 3000 : 2000, newInt);
            });
        } else if (node.type === 'market') {
            node.baseDemand *= 1.2; // +20% demand
            node.maxInventory *= 1.2;
        }
        
        spawnParticle(projection(node.coords), "UPGRADE!", "#ffd700");
        updateUI(); // Refresh cash display
        openSheet(node); // Refresh sheet with new stats/cost
    } else {
        // Notification removed
    }
};

window.startGame = () => {
    document.getElementById('title-screen').style.display = 'none';
    setSpeed(0); // Ensure starts paused and UI is synced
    updateUI();
};

window.endGame = () => {
    state.speed = 0;
    document.getElementById('end-screen').style.display = 'flex';
    document.getElementById('final-cash').innerText = '$' + formatInt(state.cash);
    
    // KPI Calculation
    const markets = state.nodes.filter(n => n.type === 'market');
    const avgFresh = markets.reduce((acc, m) => acc + m.quality, 0) / (markets.length || 1);
    
    // Inventory Turnover = Total Sales / Avg Inventory
    // Use history for avg inventory (sampled daily)
    const histInv = state.history.inventory;
    const avgInv = histInv.length > 0 ? histInv.reduce((a,b)=>a+b,0)/histInv.length : state.nodes.reduce((a,n)=>a+n.inventory,0);
    const turnover = avgInv > 0 ? state.totalSales / avgInv : 0;

    document.getElementById('final-fresh').innerText = (avgFresh * 100).toFixed(0) + '%';
    document.getElementById('final-fresh').style.color = avgFresh > 0.8 ? '#3fb950' : (avgFresh > 0.5 ? '#d29922' : '#f85149');
    
    document.getElementById('final-missed').innerText = formatInt(state.totalLostSales);
    document.getElementById('final-turnover').innerText = turnover.toFixed(1) + 'x';
};

window.replayGame = () => {
    document.getElementById('end-screen').style.display = 'none';
    resetState();
    initGameLogic();
    state.speed = 0;
    resetZoom(); // Optional: reset camera
    updateUI();
};

function resetState() {
    state = {
        cash: CONFIG.startCash,
        day: 1.0,
        lastIntegerDay: 1,
        timeAccumulator: 0,
        speed: 0,
        nodes: [],
        routes: [],
        units: [],
        particles: [],
        booms: [],
        history: { cash: [], inventory: [], days: [], demand: [], production: [] },
        totalSales: 0,
        totalLostSales: 0,
        selectedNodeId: null,
        lastTick: 0,
        transform: state.transform || d3.zoomIdentity,
        uiTimer: 0
    };
}

init();
</script>
</body>
</html>
