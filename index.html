<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Global Supply Chain Tycoon</title>
    <link rel="icon" href="data:,">
    <style>
        :root {
            --bg-color: #0d1117;
            --panel-bg: rgba(22, 27, 34, 0.7);
            --panel-border: rgba(48, 54, 61, 0.6);
            --text-primary: #f0f6fc;
            --text-secondary: #8b949e;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--font-family);
            color: var(--text-primary);
            user-select: none;
            -webkit-font-smoothing: antialiased;
            touch-action: none;
        }

        #game-container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #map-svg, #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #map-svg { z-index: 1; pointer-events: all; }
        #game-canvas { z-index: 2; pointer-events: none; }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        
        /* Ensure interactive elements catch clicks */
        #selection-sheet, .fab-btn, .switch, button {
            pointer-events: auto;
        }

        #status-bar {
            width: 100%;
            padding: 16px 20px;
            box-sizing: border-box;
            background: linear-gradient(180deg, rgba(13, 17, 23, 0.9) 0%, rgba(13, 17, 23, 0) 100%);
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none;
        }

        .stat-group {
            display: flex;
            flex-direction: column;
            gap: 2px;
            text-shadow: 0 2px 4px rgba(0,0,0,0.8);
        }
        .stat-label {
            font-size: 11px;
            letter-spacing: 1px;
            color: var(--text-secondary);
            font-weight: 700;
        }
        .stat-value {
            font-size: 20px;
            font-weight: 700;
            font-variant-numeric: tabular-nums;
            letter-spacing: -0.5px;
        }

        #notification-area {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            width: 90%;
            max-width: 400px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            pointer-events: none;
            z-index: 20;
        }
        .toast {
            background: rgba(22, 27, 34, 0.7);
            /* backdrop-filter: blur(8px); REMOVED for performance */
            border: 1px solid var(--panel-border);
            padding: 6px 12px;
            border-radius: 30px;
            font-size: 14px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.4);
            display: flex;
            align-items: center;
            gap: 6px;
            opacity: 0;
            transform: translateY(-20px) scale(0.95);
            animation: toastIn 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }
        .toast-icon { font-size: 16px; }
        .toast.warn { border-bottom: 2px solid var(--accent-red); }
        .toast.info { border-bottom: 2px solid var(--accent-blue); }

        @keyframes toastIn {
            to { opacity: 1; transform: translateY(0) scale(1); }
        }

        #bottom-area {
            padding: 20px;
            pointer-events: none;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            position: relative;
        }

        .fab-container {
            pointer-events: auto;
            position: absolute;
            top: 80px; /* Below Timeline */
            right: 20px;
            display: flex;
            flex-direction: column; /* Vertical layout */
            align-items: center;
            gap: 4px;
            z-index: 30;
        }
        
        .zoom-controls {
            pointer-events: auto;
            position: absolute;
            top: 80px; /* Below Net Cash */
            left: 20px;
            display: flex;
            flex-direction: column;
            gap: 4px;
            z-index: 20;
            background: rgba(22, 27, 34, 0.8);
            padding: 2px;
            border-radius: 30px;
            border: 1px solid var(--panel-border);
        }
        
        .legend-container {
            pointer-events: auto;
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            background: rgba(22, 27, 34, 0.8);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid var(--panel-border);
            display: flex;
            align-items: center;
            justify-content: center; /* Center items */
            flex-wrap: wrap; /* Allow wrapping */
            gap: 12px;
            width: max-content; /* Fit content */
            max-width: 90vw; /* Prevent overflow */
        }

        .legend-row {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .legend-divider {
            width: 1px;
            height: 12px;
            background: rgba(255,255,255,0.1);
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .fab-menu {
            display: flex;
            flex-direction: column; /* Vertical layout */
            gap: 4px;
            opacity: 1;
            transform: none;
            pointer-events: auto;
            background: rgba(22, 27, 34, 0.8);
            padding: 2px;
            border-radius: 30px;
            border: 1px solid var(--panel-border);
        }
        
        .fab-btn {
            width: 40px; /* Slightly smaller */
            height: 40px;
            border-radius: 50%;
            border: none;
            background: transparent;
            color: var(--text-secondary);
            font-weight: bold;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
            font-family: var(--font-family);
            font-size: 14px;
        }
        .fab-btn:active { transform: scale(0.92); }
        .fab-btn.active { 
            background: var(--accent-blue); 
            color: white; 
            box-shadow: 0 2px 8px rgba(59, 130, 246, 0.4);
        }
        .fab-main { display: none !important; } /* Hide the lightning button */

        #selection-sheet {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: var(--panel-bg);
            /* backdrop-filter: blur(12px); REMOVED for performance */
            border-top: 1px solid var(--panel-border);
            border-radius: 24px 24px 0 0;
            box-shadow: 0 -8px 32px rgba(0,0,0,0.5);
            transform: translateY(110%);
            transition: transform 0.35s cubic-bezier(0.2, 0.8, 0.2, 1);
            pointer-events: auto;
            max-height: 85vh; /* Increased from 70vh to allow more space */
            display: flex;
            flex-direction: column;
            z-index: 100;
        }
        #selection-sheet.active {
            transform: translateY(0);
        }

        .sheet-handle {
            width: 40px;
            height: 4px;
            background: rgba(255,255,255,0.2);
            border-radius: 2px;
            margin: 12px auto 4px auto;
        }

        .sheet-header {
            padding: 12px 24px 20px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .sheet-title {
            margin: 0;
            font-size: 20px;
            font-weight: 700;
            letter-spacing: -0.5px;
        }
        .close-btn {
            background: rgba(255,255,255,0.1);
            border: none;
            color: var(--text-secondary);
            width: 32px;
            height: 32px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .sheet-content {
            padding: 0 24px 80px 24px; /* Increased padding to clear system UI */
            flex: 1; /* Take remaining height */
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            touch-action: pan-y; /* Explicitly allow vertical scroll */
            overscroll-behavior: contain; /* Prevent scroll chaining to body */
            padding-bottom: max(100px, env(safe-area-inset-bottom)); /* More padding for scroll */
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 12px;
            margin-bottom: 16px;
        }
        .stat-card {
            background: rgba(255,255,255,0.03);
            padding: 12px 16px;
            border-radius: 12px;
            border: 1px solid var(--panel-border);
        }
        .stat-card-label { font-size: 11px; color: var(--text-secondary); margin-bottom: 6px; font-weight: 600; }
        .stat-card-value { font-size: 16px; font-weight: 600; color: var(--text-primary); }

        .routes-section h3 {
            font-size: 13px;
            color: var(--text-secondary);
            letter-spacing: 1px;
            margin: 0 0 16px 0;
            font-weight: 700;
        }

        .route-card {
            background: rgba(255,255,255,0.03);
            border-radius: 16px;
            padding: 16px;
            margin-bottom: 12px;
            border: 1px solid transparent;
        }

        .route-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }
        .route-dest { font-weight: 700; font-size: 16px; }

        .transport-option {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 0;
            border-top: 1px solid rgba(255,255,255,0.05);
            font-size: 14px;
        }
        .transport-info { display: flex; gap: 10px; align-items: center; color: var(--text-secondary); }
        .transport-cost { font-size: 0.9em; opacity: 0.7; background: rgba(255,255,255,0.1); padding: 2px 6px; border-radius: 4px; }

        .switch {
            position: relative;
            display: inline-block;
            width: 44px;
            height: 24px;
        }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0; left: 0; right: 0; bottom: 0;
            background-color: #30363d;
            transition: .3s;
            border-radius: 34px;
            border: 1px solid #6e7681;
        }
        .slider:before {
            position: absolute;
            content: "";
            height: 18px; width: 18px;
            left: 2px; bottom: 2px;
            background-color: white;
            transition: .3s;
            border-radius: 50%;
        }
        input:checked + .slider { background-color: var(--accent-green); border-color: var(--accent-green); }
        input:checked + .slider:before { transform: translateX(20px); }

        /* Portrait Mobile Optimization */
        @media (max-width: 600px) and (orientation: portrait) {
            #notification-area {
                top: 140px !important;
            }
            .legend-container {
                flex-direction: column !important;
                gap: 4px !important;
                padding: 6px 12px !important;
                top: 80px !important; /* Align with zoom/speed controls */
            }
            .legend-divider { display: none !important; }
        }

        /* Landscape Mobile Optimization */
        @media (max-height: 500px) and (orientation: landscape) {
            #notification-area {
                top: 60px !important; /* Below legend */
            }
            body, html { overflow: hidden !important; position: fixed; width: 100%; height: 100%; }
            
            #status-bar { 
                padding: 4px 12px;
                padding-right: max(12px, env(safe-area-inset-right)); /* Safe area */
                background: linear-gradient(180deg, rgba(13, 17, 23, 0.95) 0%, rgba(13, 17, 23, 0.8) 100%);
                z-index: 15;
            }
            .stat-label { font-size: 9px; }
            .stat-value { font-size: 14px; }
            
            /* Hide bottom area wrapper */
            #bottom-area { display: none !important; }
            
            /* Positions are already good for landscape (corners), just tweak spacing */
            .zoom-controls { top: 60px; left: 10px; bottom: auto; }
            .fab-container { 
                top: 60px; 
                right: max(10px, env(safe-area-inset-right)); /* Safe area */
                bottom: auto; 
            }
            
            .legend-container { 
                top: 12px; /* Center top */
                bottom: auto;
                left: 50%; 
                transform: translateX(-50%); 
                padding: 6px 12px !important;
                background: rgba(22, 27, 34, 0.9) !important;
                flex-direction: row !important; /* Single row for landscape */
                gap: 12px !important;
            }
            .legend-divider { display: block !important; }
            
            #selection-sheet {
                position: fixed !important; /* Force fixed to viewport */
                width: 40% !important;
                min-width: 300px;
                top: 0 !important;
                height: 100vh !important;
                max-height: 100vh !important;
                border-radius: 0 !important;
                z-index: 1000;
                transition: transform 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            }
            
            /* Default / Right Panel */
            #selection-sheet:not(.panel-left) {
                right: 0 !important;
                left: auto !important;
                border-left: 1px solid var(--panel-border);
                transform: translateX(100%);
            }
            #selection-sheet:not(.panel-left).active { transform: translateX(0); }

            /* Left Panel Override */
            #selection-sheet.panel-left {
                left: 0 !important;
                right: auto !important;
                border-right: 1px solid var(--panel-border);
                border-left: none;
                transform: translateX(-100%);
            }
            #selection-sheet.panel-left.active { transform: translateX(0); }
        }

        /* Overlay Screens */
        .overlay-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(13, 17, 23, 0.98);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            z-index: 2000;
            /* backdrop-filter: blur(10px); Removed for performance compatibility */
        }
        .overlay-screen h1 {
            font-size: 40px; margin-bottom: 10px; color: var(--text-primary);
            letter-spacing: 2px; text-align: center;
            line-height: 1.2;
        }
        .primary-btn {
            padding: 16px 48px; font-size: 18px; font-weight: bold;
            background: var(--accent-green); color: white; border: none; border-radius: 8px;
            cursor: pointer; transition: transform 0.2s, background 0.2s;
            box-shadow: 0 4px 12px rgba(63, 185, 80, 0.3);
        }
        .primary-btn:hover { background: #4ac26b; }
        .primary-btn:active { transform: scale(0.95); }
        
        .final-score { margin-bottom: 24px; text-align: center; }
        .score-label { color: var(--text-secondary); font-size: 14px; letter-spacing: 1px; margin-bottom: 4px; }
        .score-value { font-size: 36px; font-weight: 800; color: var(--text-primary); letter-spacing: -1px; }
    </style>
</head>
<body>

<div id="title-screen" class="overlay-screen">
    <h1 style="text-transform: none;">Global Supply<br>Chain Tycoon</h1>
    <p style="color:#8b949e; margin-bottom:20px; font-size:14px;">Manage routes, control inventory, and maximize profit.</p>
    
    <div style="margin-bottom:30px; text-align:center;">
        <p style="font-size:12px; color:var(--text-secondary); margin-bottom:10px;">Select Game Duration</p>
        <div style="display:flex; gap:10px; justify-content:center;">
            <button class="fab-btn active" id="btn-1y" onclick="setDuration(1)" style="width:60px; border-radius:8px;">1 Yr</button>
            <button class="fab-btn" id="btn-3y" onclick="setDuration(3)" style="width:60px; border-radius:8px;">3 Yr</button>
            <button class="fab-btn" id="btn-5y" onclick="setDuration(5)" style="width:60px; border-radius:8px;">5 Yr</button>
        </div>
    </div>
    
    <button class="primary-btn" onclick="startGame()">Start Game</button>
</div>

<div id="end-screen" class="overlay-screen" style="display:none;">
    <h1>Game Over</h1>
    <div class="final-score">
        <div class="score-label">Final Net Cash</div>
        <div class="score-value" id="final-cash">$0</div>
    </div>
    
    <div style="display:grid; grid-template-columns: 1fr 1fr 1fr; gap:20px; margin-bottom:30px;">
        <div style="text-align:center;">
            <div class="score-label">Avg Freshness</div>
            <div class="score-value" style="font-size:24px;" id="final-fresh">-</div>
        </div>
        <div style="text-align:center;">
            <div class="score-label">Missed Sales</div>
            <div class="score-value" style="font-size:24px; color:var(--accent-red);" id="final-missed">-</div>
        </div>
        <div style="text-align:center;">
            <div class="score-label">Inv. Turnover</div>
            <div class="score-value" style="font-size:24px;" id="final-turnover">-</div>
        </div>
    </div>
    <button class="primary-btn" onclick="replayGame()">Play Again</button>
</div>

<div id="game-container">
    <svg id="map-svg"><g></g></svg>
    <canvas id="game-canvas"></canvas>

    <div id="ui-layer">
        <div id="status-bar">
            <div class="stat-group" onclick="toggleDashboard()" style="cursor:pointer; pointer-events:auto;">
                <div class="stat-label">Net Cash <span style="font-size:10px; opacity:0.7;">‚ÑπÔ∏è</span></div>
                <div class="stat-value" id="cash-display">$100k</div>
            </div>
            <div class="stat-group" onclick="toggleHistory()" style="align-items: flex-end; cursor:pointer; pointer-events:auto;">
                <div class="stat-label">üìà <span id="year-display">Year 1 / 1</span></div>
                <div class="stat-value" id="time-display">Day 1</div>
            </div>
        </div>

        <div id="notification-area"></div>

        <div id="notification-area"></div>

        <!-- Controls moved out of bottom-area for independent positioning -->
        <div class="zoom-controls">
            <button class="fab-btn" onclick="adjustZoom(1.5)">+</button>
            <button class="fab-btn" onclick="adjustZoom(0.66)">-</button>
            <button class="fab-btn" style="font-size: 12px;" onclick="resetZoom()">1:1</button>
        </div>

        <div class="legend-container">
            <div class="legend-row">
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-red);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Raw</span></div>
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-yellow);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Factory</span></div>
                <div class="legend-item"><div style="width:10px; height:10px; border-radius:50%; background:var(--accent-green);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Market</span></div>
            </div>
            <div class="legend-divider"></div>
            <div class="legend-row">
                <div class="legend-item"><div style="width:10px; height:10px; background:var(--accent-blue);"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Ship</span></div>
                <div class="legend-item"><div style="width: 0; height: 0; border-left: 5px solid transparent; border-right: 5px solid transparent; border-bottom: 9px solid #f0f6fc;"></div><span style="font-size:11px; font-weight:600; color:var(--text-secondary);">Air</span></div>
            </div>
        </div>

        <div class="fab-container">
            <div class="fab-menu" id="speed-menu">
                <button class="fab-btn" onclick="cycleFastSpeed()">‚è©</button>
                <button class="fab-btn" onclick="setSpeed(1)">‚ñ∂</button>
                <button class="fab-btn active" onclick="setSpeed(0)">‚è∏</button>
            </div>
        </div>

        <div id="bottom-area">
            <!-- Empty now, kept for spacing if needed -->
        </div>

        <div id="selection-sheet">
            <div class="sheet-handle"></div>
            <div class="sheet-header">
                <h2 class="sheet-title" id="sheet-title">Location</h2>
                <button class="close-btn" onclick="closePanel()">√ó</button>
            </div>
            <div class="sheet-content">
                <div class="stats-grid" id="sheet-stats"></div>
                <div class="routes-section">
                    <h3>Distribution Channels</h3>
                    <div id="sheet-routes"></div>
                </div>
            </div>
        </div>

        <!-- REBUILT DASHBOARD MODAL -->
        <div id="dashboard-modal" onclick="if(event.target===this)toggleDashboard()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:var(--panel-bg); z-index:200; overflow-y:auto; padding:20px; box-sizing:border-box; pointer-events:auto; -webkit-overflow-scrolling:touch;">
            <div style="max-width:600px; margin:0 auto;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
                    <h2 style="margin:0; font-size:24px; color:#f0f6fc;">Global Performance</h2>
                    <button onclick="toggleDashboard()" style="background:none; border:none; color:#8b949e; font-size:28px; cursor:pointer;">√ó</button>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-card-label">Total Cash</div>
                        <div class="stat-card-value" id="dash-cash">$0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Global Inventory</div>
                        <div class="stat-card-value" id="dash-inv">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Active Ships</div>
                        <div class="stat-card-value" id="dash-ships" style="color:var(--accent-blue)">0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Active Flights</div>
                        <div class="stat-card-value" id="dash-planes" style="color:var(--text-primary)">0</div>
                    </div>
                </div>
                <h3 style="margin-top:24px; color:#8b949e; font-size:14px; text-transform:uppercase;">Market Analysis</h3>
                <div id="dash-markets" style="display:flex; flex-direction:column; gap:8px;"></div>
            </div>
        </div>

        <!-- REBUILT HISTORY MODAL -->
        <div id="history-modal" onclick="if(event.target===this)toggleHistory()" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:var(--panel-bg); z-index:200; overflow-y:auto; padding:20px; box-sizing:border-box; pointer-events:auto; -webkit-overflow-scrolling:touch;">
            <div style="max-width:600px; margin:0 auto;">
                <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:24px;">
                    <h2 style="margin:0; font-size:24px; color:#f0f6fc;">Growth Trends</h2>
                    <button onclick="toggleHistory()" style="background:none; border:none; color:#8b949e; font-size:28px; cursor:pointer;">√ó</button>
                </div>
                
                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border); margin-bottom:20px;">
                    <div class="stat-label">Net Cash Trend</div>
                    <div id="cash-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>

                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border); margin-bottom:20px;">
                    <div class="stat-label">Global Inventory Trend <span style="font-size:10px; color:var(--accent-yellow); opacity:0.8;">(--- Safety Line)</span></div>
                    <div id="inv-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>

                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border); margin-bottom:20px;">
                    <div class="stat-label">Average Margin %</div>
                    <div id="margin-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>

                <div style="background:rgba(255,255,255,0.03); padding:16px; border-radius:12px; border:1px solid var(--panel-border);">
                    <div class="stat-label">Supply vs Demand Balance</div>
                    <div id="balance-chart" style="width:100%; height:150px; margin-top:10px;"></div>
                </div>
            </div>
        </div>

        <!-- YEARLY REPORT MODAL -->
        <div id="report-modal" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:var(--panel-bg); z-index:2500; display:none; flex-direction:column; align-items:center; justify-content:center; padding:20px; box-sizing:border-box;">
            <div style="max-width:500px; width:100%; background:var(--bg-color); border:1px solid var(--panel-border); border-radius:24px; padding:32px; box-shadow: 0 20px 50px rgba(0,0,0,0.5);">
                <h2 style="margin:0 0 8px 0; font-size:28px; color:var(--accent-blue); text-align:center;">Year <span id="report-year">1</span> Complete</h2>
                <p style="color:var(--text-secondary); text-align:center; margin-bottom:24px;">Annual Performance Review</p>
                
                <div class="stats-grid" style="margin-bottom:24px;">
                    <div class="stat-card">
                        <div class="stat-card-label">Annual Revenue</div>
                        <div class="stat-card-value" id="report-revenue">$0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-card-label">Avg. Service Level</div>
                        <div class="stat-card-value" id="report-service">0%</div>
                    </div>
                </div>
                
                <button class="primary-btn" onclick="continueGame()" style="width:100%;">Continue to Year <span id="next-year">2</span></button>
            </div>
        </div>
    </div>
</div>

<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://unpkg.com/topojson@3"></script>

<script>
// --- MODULE: CONSTANTS ---
const WAYPOINTS = {
    // Canals & Straits
    panama: { coords: [-79.5, 9.0] },
    suez: { coords: [32.5, 30.0] },
    malacca: { coords: [102.0, 2.5] },
    gibraltar: { coords: [-5.5, 36.0] },
    canaryPass: { coords: [-18.0, 28.0] },
    portugalWest: { coords: [-10.5, 40.0] },
    hormuz: { coords: [56.0, 26.5] },
    babAlMandab: { coords: [43.3, 12.6] },
    dover: { coords: [1.3, 51.1] },
    
    // Capes
    capeGoodHope: { coords: [18.5, -34.5] },
    capeAgulhas: { coords: [25.0, -36.0] },
    capeHorn: { coords: [-67.0, -56.0] },
    
    // Hubs / Sea Regions
    sriLanka: { coords: [80.5, 6.0] },
    taiwan: { coords: [121.5, 23.5] },
    hawaii: { coords: [-157.8, 21.3] },
    azores: { coords: [-25.0, 38.0] },
    
    // Oceanic Transit Points
    northAtlantic: { coords: [-40, 45] },
    midAtlantic: { coords: [-30, 10] },
    southAtlantic: { coords: [-10, -20] },
    westAfricaCoast: { coords: [8, 0] },
    namibiaCoast: { coords: [10, -25] },
    southChinaSea: { coords: [113, 15] },
    atlanticMid: { coords: [-55, 28] },
    caribbeanGate: { coords: [-65, 20] },
    cubaPass: { coords: [-82, 23] },
    arabianSea: { coords: [65, 15] },
    bayOfBengal: { coords: [90, 15] },
    seychelles: { coords: [55.5, -4.6] },
    mauritius: { coords: [57.5, -20.2] },
    mozambiqueChannel: { coords: [40.0, -15.0] },
    tasmanSea: { coords: [160.0, -40.0] }, // New waypoint for AU-US route
    brazilCoast: { coords: [-32.0, -5.0] } // Clear Brazil bulge
};

const NODES_DATA = [
    { id: 'brazil', name: 'Brazil', type: 'supply', coords: [-40, -20], portCoords: [-40, -20], production: 25, maxInventory: 3000, resourceType: 'lithium' },
    { id: 'sa', name: 'South Africa', type: 'supply', coords: [18, -34], portCoords: [18, -34], production: 6, resourceType: 'cobalt' },
    { id: 'congo', name: 'Congo', type: 'supply', coords: [12, -6], portCoords: [12, -6], production: 18, maxInventory: 2500, resourceType: 'cobalt' },
    { id: 'china', name: 'China', type: 'make', coords: [122, 30], portCoords: [122, 30], capacity: 2000, processRate: 25, bom: { 'lithium': 1, 'cobalt': 1 } },
    { id: 'india', name: 'India', type: 'make', coords: [72.8, 18.9], portCoords: [72.8, 18.9], capacity: 1750, processRate: 20, bom: { 'lithium': 1, 'cobalt': 1 } },
    { id: 'vietnam', name: 'Vietnam', type: 'make', coords: [107, 10], portCoords: [107, 10], capacity: 1500, processRate: 15, bom: { 'lithium': 1, 'cobalt': 1 } },
    { id: 'usa', name: 'USA', type: 'market', coords: [-90, 29], portCoords: [-90, 29], baseDemand: 25 },
    { id: 'germany', name: 'Germany', type: 'market', coords: [8, 54], portCoords: [8, 54], baseDemand: 20 },
    { id: 'japan', name: 'Japan', type: 'market', coords: [139.7, 35.6], portCoords: [139.7, 35.6], baseDemand: 15 },
    
    // Phase 3: Unlockable Strategic Hubs
    { id: 'australia', name: 'Australia', type: 'supply', coords: [115.8, -32.0], portCoords: [115.8, -32.0], production: 30, maxInventory: 3000, locked: true, unlockCost: 25000, resourceType: 'lithium' }, // Perth
    { id: 'mexico', name: 'Mexico', type: 'make', coords: [-96.1, 19.2], portCoords: [-96.1, 19.2], capacity: 1800, processRate: 22, locked: true, unlockCost: 40000, bom: { 'lithium': 1, 'cobalt': 1 } }, // Veracruz
    { id: 'uk', name: 'UK', type: 'market', coords: [0.1, 51.5], portCoords: [0.1, 51.5], baseDemand: 18, locked: true, unlockCost: 30000 }, // London
    { id: 'nigeria', name: 'Nigeria', type: 'market', coords: [3.4, 6.5], portCoords: [3.4, 6.5], baseDemand: 25, locked: true, unlockCost: 35000 } // Lagos
];

const CONFIG = {
    startCash: 100000,
    colors: {
        supply: '#ef4444',
        make: '#f59e0b',
        market: '#10b981',
        seaPath: 'rgba(88, 166, 255, 0.3)',
        airPath: 'rgba(255, 255, 255, 0.15)',
        text: '#f0f6fc',
        lithium: '#58a6ff',
        cobalt: '#bc8cff',
        battery: '#3fb950'
    },
    transport: {
        ship: { speed: 80, capacity: 500, costPerDispatch: 400, costPerUnit: 0.8, color: '#58a6ff', intervalFactor: 2.5 }, 
        air: { speed: 1000, capacity: 100, costPerDispatch: 400, costPerUnit: 8.0, color: '#f0f6fc', intervalFactor: 8.0 }
    },
    gameplay: {
        dayDuration: 5.0, // Seconds per game day
        qualityDecayMarket: 0.002,
        qualityDecaySupply: 0.0005,
        upgradeBoost: 1.2,
        eventFrequency: 0.01
    },
    storageCostPerUnit: 0.01,
    salePrice: 32, // Increased base price
    upgradeCosts: {
        base: 5000,
        multiplier: 1.5,
        roiThreshold: 365 
    },
    investment: {
        production: { cost: 5000, boost: 1.2, label: "Capacity" },
        quality: { cost: 8000, decayReduction: 0.8, label: "Quality Control" },
        automation: { cost: 12000, costReduction: 0.85, label: "Automation" }
    }
};

// --- MODULE: STATE ---
function getInitialState() {
    return {
        cash: CONFIG.startCash,
        day: 1.0,
        lastIntegerDay: 1,
        timeAccumulator: 0,
        speed: 0,
        preReportSpeed: 1,
        nodes: [],
        routes: [],
        units: [],
        particles: [],
        events: [], 
        notifications: [],
        history: { cash: [], inventory: [], days: [], demand: [], production: [], margin: [] },
        totalSales: 0,
        totalLostSales: 0,
        totalLostRevenue: 0,
        yearlySales: 0,
        yearlyLostSales: 0,
        yearlyLostRevenue: 0,
        yearlyCashStart: CONFIG.startCash,
        selectedNodeId: null,
        lastTick: 0,
        transform: d3.zoomIdentity,
        uiTimer: 0,
        durationYears: 1,
        currentYear: 1,
        // System Objects
        projection: null,
        pathGenerator: null,
        zoomBehavior: null,
        ctx: null,
        width: 0,
        height: 0
    };
}

let state = getInitialState();

// --- MODULE: UTILS ---
const Utils = {
    formatInt: n => Math.floor(n).toLocaleString(),
    fmtCurrency: n => n >= 1e6 ? '$' + (n/1e6).toFixed(1) + 'M' : (n >= 1e3 ? '$' + (n/1e3).toFixed(0) + 'k' : '$' + Math.floor(n)),
    getProjection: (coords) => state.projection(coords)
};

// --- MODULE: CORE ENGINE ---
function init() {
    state.svg = d3.select("#map-svg");
    state.g = state.svg.select("g");
    const canvas = document.getElementById("game-canvas");
    state.ctx = canvas.getContext("2d");

    resize();
    window.addEventListener('resize', resize);

    state.zoomBehavior = d3.zoom()
        .scaleExtent([1, 8])
        .on("zoom", (event) => {
            state.transform = event.transform;
            state.g.attr("transform", state.transform);
            render(); 
        });
    
    state.svg.call(state.zoomBehavior);
    
    d3.json("https://unpkg.com/world-atlas@2.0.2/countries-110m.json").then(worldData => {
        const countries = topojson.feature(worldData, worldData.objects.countries);
        state.g.selectAll("path")
            .data(countries.features)
            .enter().append("path")
            .attr("d", state.pathGenerator)
            .attr("fill", "#1a1f26") 
            .attr("stroke", "#30363d") 
            .attr("stroke-width", 0.5);
        
        initGameLogic();
        setDuration(1); // Initialize duration UI
        setSpeed(0); 
        
        document.getElementById('dashboard-modal').style.display = 'none';
        document.getElementById('history-modal').style.display = 'none';
        
        requestAnimationFrame(gameLoop);
        render(); 
    });
}

function resize() {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    const canvas = document.getElementById("game-canvas");
    canvas.width = state.width * window.devicePixelRatio;
    canvas.height = state.height * window.devicePixelRatio;
    canvas.style.width = state.width + "px";
    canvas.style.height = state.height + "px";
    
    if (state.ctx) {
        state.ctx.setTransform(1,0,0,1,0,0);
        state.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    }
    
    const isPortrait = state.height > state.width;
    const translateY = isPortrait ? state.height * 0.4 : state.height / 1.8;

    state.projection = d3.geoNaturalEarth1()
        .scale(state.width / 6.5)
        .translate([state.width / 2, translateY]);
        
    state.pathGenerator = d3.geoPath().projection(state.projection);
    if (state.g) state.g.selectAll("path").attr("d", state.pathGenerator);
}

function initGameLogic() {
    state.nodes = NODES_DATA.map(n => {
        // More realistic initial costs (Embedded costs for starting inventory)
        let r = 0, t = 0, m = 0;
        if (n.type === 'supply') {
            r = (n.id === 'sa' ? 8.0 : 5.0);
        } else if (n.type === 'make') {
            r = 6.0; t = 2.0; m = (n.id === 'china' ? 8.0 : (n.id === 'vietnam' ? 6.0 : 10.0));
        } else if (n.type === 'market') {
            r = 6.0; t = 4.0; m = 8.0;
        }
        const unitCost = r + t + m;

        // Phase 3: Handle locked nodes
        if (n.locked) {
            // Phase 4: Initialize inputs for factories (BOM)
            const inputs = n.type === 'make' ? Object.keys(n.bom || {}).reduce((acc, k) => ({ ...acc, [k]: 0 }), {}) : null;

            return {
                ...n,
                inventory: 0,
                maxInventory: n.maxInventory || 1500,
                inputs: inputs,
                stalledDays: 0,
                demand: 0, // Demand activates on unlock
                level: 1,
                levels: { production: 1, quality: 1, automation: 1 },
                quality: 1.0,
                baseQualityDecay: n.type === 'market' ? CONFIG.gameplay.qualityDecayMarket : CONFIG.gameplay.qualityDecaySupply,
                costs: { raw: r, transport: t, make: m, storage: 0 },
                baseCosts: { raw: r, make: m },
                unitCost: unitCost,
                phase: Math.random() * Math.PI * 2,
                screenPos: state.projection(n.coords),
                alert: 0,
                locked: true,
                unlockCost: n.unlockCost || 30000
            };
        }

        // Phase 4: Initialize inputs for factories (BOM)
        const inputs = n.type === 'make' ? Object.keys(n.bom || {}).reduce((acc, k) => ({ ...acc, [k]: 0 }), {}) : null;

        return {
            ...n,
            inventory: n.type === 'supply' ? 500 : 100, 
            maxInventory: n.maxInventory || n.capacity || 1500,
            inputs: inputs,
            stalledDays: 0,
            demand: 0,
            level: 1, // Legacy level tracking
            levels: { production: 1, quality: 1, automation: 1 }, // New specialized levels
            quality: 1.0, 
            baseQualityDecay: n.type === 'market' ? CONFIG.gameplay.qualityDecayMarket : CONFIG.gameplay.qualityDecaySupply,
            costs: {
                raw: r,
                transport: t,
                make: m,
                storage: 0
            },
            baseCosts: { raw: r, make: m }, // Store base costs for reduction calc
            unitCost: unitCost,
            phase: Math.random() * Math.PI * 2, 
            screenPos: state.projection(n.coords),
            alert: 0
        };
    });

    const addRoute = (from, to) => {
        const fNode = state.nodes.find(n => n.id === from);
        const tNode = state.nodes.find(n => n.id === to);
        // Routes connected to locked nodes are not commissioned initially
        const isCommissioned = !fNode.locked && !tNode.locked;
        
        state.routes.push(createRoute(fNode, tNode, 'ship', isCommissioned));
        state.routes.push(createRoute(fNode, tNode, 'air', isCommissioned));
    };

    const supply = state.nodes.filter(n => n.type === 'supply');
    const make = state.nodes.filter(n => n.type === 'make');
    const market = state.nodes.filter(n => n.type === 'market');

    supply.forEach(s => make.forEach(m => addRoute(s.id, m.id)));
    make.forEach(m => market.forEach(k => addRoute(m.id, k.id)));

    state.speed = 0;
}

// --- MODULE: NAUTICAL ENGINE ---
function createRoute(fromNode, toNode, type, isCommissioned = true) {
    let rawPoints = [];
    if (type === 'air') {
        rawPoints = [fromNode.coords, toNode.coords];
    } else {
        const start = fromNode.portCoords || fromNode.coords;
        const end = toNode.portCoords || toNode.coords;
        
        // HARDCODED FIX for Australia-Mexico to prevent any logic errors
        if ((fromNode.id === 'australia' && toNode.id === 'mexico') || (fromNode.id === 'mexico' && toNode.id === 'australia')) {
             const p = [
                 // Direct to Sri Lanka, skipping Malacca
                 WAYPOINTS.sriLanka.coords, WAYPOINTS.arabianSea.coords, 
                 WAYPOINTS.babAlMandab.coords, WAYPOINTS.suez.coords, WAYPOINTS.gibraltar.coords, 
                 WAYPOINTS.canaryPass.coords, 
                 // Direct Atlantic crossing like India-USA route
                 WAYPOINTS.caribbeanGate.coords, WAYPOINTS.cubaPass.coords
             ];
             rawPoints = fromNode.id === 'australia' ? [start, ...p, end] : [start, ...p.reverse(), end];
        } else {
            rawPoints = getShipPath(start, end);
        }
    }
    
    const pathCoords = densifyPath(rawPoints, 0.005);
    let totalVisualDist = 0;
    const segmentDists = [];
    
    for(let i=0; i<pathCoords.length-1; i++) {
        const p1 = state.projection(pathCoords[i]);
        const p2 = state.projection(pathCoords[i+1]);
        let d = 0;
        if (p1 && p2) {
            const dist = Math.hypot(p1[0]-p2[0], p1[1]-p2[1]);
            if (dist < state.width * 0.5) d = dist;
        }
        segmentDists.push(d);
        totalVisualDist += d;
    }

    let acc = 0;
    const visualStops = [0];
    for (const d of segmentDists) {
        acc += d;
        visualStops.push(totalVisualDist > 0 ? acc / totalVisualDist : 1);
    }

    const speedPx = CONFIG.transport[type].speed * 0.04; 
    const travelTimeMs = (totalVisualDist / speedPx) * 1000;
    const travelTimeDays = (travelTimeMs / 1000) / CONFIG.gameplay.dayDuration;

    let targetDemand = toNode.type === 'market' ? toNode.baseDemand : (toNode.type === 'make' ? toNode.processRate : 10);
    const intervalFactor = CONFIG.transport[type].intervalFactor;

    let interval = (CONFIG.transport[type].capacity / Math.max(1, targetDemand)) * 1000 * intervalFactor;
    interval = Math.max(2500, Math.min(150000, interval));
    const intervalDays = (interval / 1000) / CONFIG.gameplay.dayDuration;

    return {
        id: `${fromNode.id}-${toNode.id}-${type}`,
        from: fromNode.id, to: toNode.id, type, 
        active: isCommissioned && type === 'ship', // Only commissioned ship routes active by default
        commissioned: isCommissioned, // Phase 3: Route Commissioning
        commissionCost: type === 'ship' ? 5000 : 2000, // Cost to open route
        timer: Math.random() * interval, 
        interval: interval,
        travelTimeDays: travelTimeDays,
        intervalDays: intervalDays,
        pathCoords: pathCoords,
        visualStops: visualStops,           
        totalVisualDistance: totalVisualDist 
    };
}

function densifyPath(points, resolution = 0.05) {
    if (points.length < 2) return points;
    let dense = [];
    for (let i = 0; i < points.length - 1; i++) {
        const start = points[i];
        const end = points[i+1];
        const dist = d3.geoDistance(start, end);
        const segments = Math.max(1, Math.ceil(dist / resolution));
        
        const interpolator = d3.geoInterpolate(start, end);
        for (let t = 0; t < 1; t += 1/segments) {
            dense.push(interpolator(t));
        }
    }
    dense.push(points[points.length - 1]);
    return dense;
}

function findRoute(fromId, toId, type) {
    return state.routes.find(r => r.from === fromId && r.to === toId && r.type === type);
}

function getShipPath(start, end) {
    const [sLon, sLat] = start;
    const [eLon, eLat] = end;
    
    const getRegion = (lon, lat) => {
        if (lon < -30) return 'americas';
        if (lon >= -30 && lon < 50 && lat > 20) return 'europe';
        if (lon >= -20 && lon < 60 && lat <= 20) return 'africa';
        if (lon >= 60) return 'asia';
        return 'unknown';
    };

    const sR = getRegion(sLon, sLat), eR = getRegion(eLon, eLat);
    const pair = [sR, eR].sort().join('-'); 
    const isWestAsia = lon => lon < 95;
    const isAustralia = (lon, lat) => lat < -10 && lon > 110 && lon < 160;

    // 0. Australia Special Routing
    if (isAustralia(sLon, sLat) || isAustralia(eLon, eLat)) {
        const aus = isAustralia(sLon, sLat) ? start : end;
        const other = isAustralia(sLon, sLat) ? end : start;
        const otherLon = other[0];
        
        // Australia <-> Asia/Europe/Africa (Go via Malacca/Sunda)
        if (other[1] > -10 && otherLon < 130) {
            let p = [WAYPOINTS.malacca.coords];
            if (otherLon < 80) p.unshift(WAYPOINTS.sriLanka.coords); // To India/Africa/Europe
            if (otherLon > 115) p.push(WAYPOINTS.southChinaSea.coords); // To China/Japan
            
            // To Europe/Africa add more
            if (otherLon < 60) {
                p.unshift(WAYPOINTS.arabianSea.coords, WAYPOINTS.babAlMandab.coords, WAYPOINTS.suez.coords, WAYPOINTS.gibraltar.coords);
                if (other[1] > 40) p.push(WAYPOINTS.dover.coords); // UK/Germany
            }
            
            return isAustralia(sLon, sLat) ? [start, ...p, end] : [start, ...p.reverse(), end];
        }
        
        // Australia <-> Americas (FORCE WEST via Suez/Cape)
        const isAmericas = lon => lon < -30 && lon > -160;
        const sIsAmericas = isAmericas(sLon);
        const eIsAmericas = isAmericas(eLon);
        const sIsAus = isAustralia(sLon, sLat);
        const eIsAus = isAustralia(eLon, eLat);

        if ((sIsAus && eIsAmericas) || (sIsAmericas && eIsAus)) {
             // Path: Malacca -> ... -> Atlantic -> Americas
             let p = [
                 WAYPOINTS.malacca.coords, 
                 WAYPOINTS.sriLanka.coords, 
                 WAYPOINTS.arabianSea.coords, 
                 WAYPOINTS.babAlMandab.coords, 
                 WAYPOINTS.suez.coords, 
                 WAYPOINTS.gibraltar.coords, 
                 WAYPOINTS.canaryPass.coords, 
                 WAYPOINTS.midAtlantic.coords, 
                 WAYPOINTS.atlanticMid.coords 
             ];
             
             // Determine the Americas point (either start or end)
             const amPoint = sIsAmericas ? start : end;
             
             if (amPoint[1] < 10 && amPoint[1] > -30) { // To Brazil
                 // Brazil path logic...
             } else {
                 // To Mexico/US East
                 p.push(WAYPOINTS.caribbeanGate.coords); 
                 if (amPoint[0] < -85) p.push(WAYPOINTS.cubaPass.coords); 
             }
             
             // If start is Australia, use P as is. If start is Americas, reverse P.
             return sIsAus ? [start, ...p, end] : [start, ...p.reverse(), end];
        } 
        
        // Handle West Coast US separately (Pacific route)
        // Only if one is Australia and the other is explicitly West Coast (<= -120)
        // (This block is technically unreachable now if isAmericas includes -160, 
        //  but keep for safety if definition changes)
        if (otherLon <= -120 || (isAustralia(otherLon, other[1]) && sLon <= -120)) { 
             const p = [WAYPOINTS.tasmanSea.coords, WAYPOINTS.hawaii.coords];
             return isAustralia(sLon, sLat) ? [start, ...p, end] : [start, ...p.reverse(), end];
        }
    }

    // 1. Asia <-> Asia
    if (pair === 'asia-asia') {
        if ((isWestAsia(sLon) && !isWestAsia(eLon)) || (!isWestAsia(sLon) && isWestAsia(eLon))) {
            let p = [WAYPOINTS.sriLanka.coords, WAYPOINTS.malacca.coords];
            const asianDestLon = sLon < eLon ? eLon : sLon;
            if (asianDestLon > 110) p.push(WAYPOINTS.southChinaSea.coords);
            if (asianDestLon > 125) p.push(WAYPOINTS.taiwan.coords);
            return sLon < eLon ? [start, ...p, end] : [start, ...p.reverse(), end];
        }
    }

    // 2. Americas <-> Asia
    if (pair === 'americas-asia') {
        const asianLon = sR === 'asia' ? sLon : eLon;
        const isBrazil = (sR === 'americas' ? sLat : eLat) < 0;
        
        if (isBrazil) {
            let p = [WAYPOINTS.capeGoodHope.coords, WAYPOINTS.capeAgulhas.coords, WAYPOINTS.mozambiqueChannel.coords];
            if (isWestAsia(asianLon)) {
                p.push(WAYPOINTS.seychelles.coords, WAYPOINTS.arabianSea.coords);
            } else {
                if (asianLon > 85) p.push(WAYPOINTS.sriLanka.coords);
                if (asianLon > 105) p.push(WAYPOINTS.malacca.coords);
                if (asianLon > 115) p.push(WAYPOINTS.southChinaSea.coords);
                if (asianLon > 130) p.push(WAYPOINTS.taiwan.coords);
            }
            return sR === 'americas' ? [start, ...p, end] : [start, ...p.reverse(), end];
        }

        if (isWestAsia(asianLon)) {
            let p = [WAYPOINTS.cubaPass.coords, WAYPOINTS.caribbeanGate.coords, WAYPOINTS.canaryPass.coords, WAYPOINTS.gibraltar.coords, WAYPOINTS.suez.coords, WAYPOINTS.babAlMandab.coords, WAYPOINTS.arabianSea.coords];
            return sR === 'americas' ? [start, ...p, end] : [start, ...p.reverse(), end];
        } else {
            const p = [WAYPOINTS.taiwan.coords, WAYPOINTS.hawaii.coords, WAYPOINTS.panama.coords];
            return sR === 'asia' ? [start, ...p, end] : [start, ...p.reverse(), end];
        }
    }

    // 3. Asia <-> Europe (Suez)
    if (pair === 'asia-europe') {
        const asianPoint = sR === 'asia' ? start : end;
        const euroPoint = sR === 'europe' ? start : end;
        const lon = asianPoint[0];
        let p = [];
        
        if (sR === 'asia') {
            if (lon > 125) p.push(WAYPOINTS.taiwan.coords);
            if (lon > 115) p.push(WAYPOINTS.southChinaSea.coords);
            if (lon > 105) p.push(WAYPOINTS.malacca.coords);
            if (lon > 85) p.push(WAYPOINTS.sriLanka.coords);
            p.push(WAYPOINTS.arabianSea.coords, WAYPOINTS.babAlMandab.coords, WAYPOINTS.suez.coords, WAYPOINTS.gibraltar.coords);
            if (euroPoint[1] > 40) p.push(WAYPOINTS.portugalWest.coords, WAYPOINTS.dover.coords);
            return [start, ...p, end];
        } else {
            if (euroPoint[1] > 40) p.push(WAYPOINTS.dover.coords, WAYPOINTS.portugalWest.coords);
            p.push(WAYPOINTS.gibraltar.coords, WAYPOINTS.suez.coords, WAYPOINTS.babAlMandab.coords, WAYPOINTS.arabianSea.coords);
            if (lon > 85) p.push(WAYPOINTS.sriLanka.coords);
            if (lon > 105) p.push(WAYPOINTS.malacca.coords);
            if (lon > 115) p.push(WAYPOINTS.southChinaSea.coords);
            if (lon > 125) p.push(WAYPOINTS.taiwan.coords);
            return [start, ...p, end];
        }
    }

    // 4. Africa <-> Asia
    if (pair === 'africa-asia') {
        const asianLon = sR === 'asia' ? sLon : eLon;
        let p = [];
        if (sR === 'africa') {
            if (sLat > -30 && sLon < 20) p.push(WAYPOINTS.namibiaCoast.coords);
            p.push(WAYPOINTS.capeGoodHope.coords, WAYPOINTS.capeAgulhas.coords, WAYPOINTS.mozambiqueChannel.coords);
            if (isWestAsia(asianLon)) p.push(WAYPOINTS.seychelles.coords, WAYPOINTS.arabianSea.coords);
            if (asianLon > 85) p.push(WAYPOINTS.sriLanka.coords);
            if (asianLon > 105) p.push(WAYPOINTS.malacca.coords);
            if (asianLon > 115) p.push(WAYPOINTS.southChinaSea.coords);
            if (asianLon > 130) p.push(WAYPOINTS.taiwan.coords);
            return [start, ...p, end];
        } else {
            if (asianLon > 130) p.push(WAYPOINTS.taiwan.coords);
            if (asianLon > 115) p.push(WAYPOINTS.southChinaSea.coords);
            if (asianLon > 105) p.push(WAYPOINTS.malacca.coords);
            if (asianLon > 85) p.push(WAYPOINTS.sriLanka.coords);
            if (isWestAsia(asianLon)) p.push(WAYPOINTS.arabianSea.coords, WAYPOINTS.seychelles.coords);
            p.push(WAYPOINTS.mozambiqueChannel.coords, WAYPOINTS.capeAgulhas.coords, WAYPOINTS.capeGoodHope.coords);
            if (eLat > -30 && eLon < 20) p.push(WAYPOINTS.namibiaCoast.coords);
            return [start, ...p, end];
        }
    }

    // 5. Americas <-> Europe
    if (pair === 'americas-europe') {
        const p = [WAYPOINTS.azores.coords];
        return sR === 'americas' ? [start, ...p, end] : [start, ...p.reverse(), end];
    }

    // 5.5 Americas <-> Americas (Brazil <-> Mexico/USA)
    if (pair === 'americas-americas') {
        // If crossing the Amazon/North Brazil bulge, go around
        const southPoint = sLat < eLat ? start : end;
        const northPoint = sLat < eLat ? end : start;
        
        if (southPoint[1] < 0 && northPoint[1] > 10) { // Brazil to Mexico/USA
            // Go via Brazil Coast to clear the bulge efficiently
            let p = [WAYPOINTS.brazilCoast.coords, WAYPOINTS.caribbeanGate.coords];
            if (northPoint[0] < -85) p.push(WAYPOINTS.cubaPass.coords); // Into Gulf
            return sLat < eLat ? [start, ...p, end] : [start, ...p.reverse(), end];
        }
    }

    // 5.6 Africa <-> Americas
    if (pair === 'africa-americas') {
        const p = [WAYPOINTS.midAtlantic.coords, WAYPOINTS.caribbeanGate.coords];
        if (eLon < -85 || sLon < -85) p.push(WAYPOINTS.cubaPass.coords);
        return sR === 'africa' ? [start, ...p, end] : [start, ...p.reverse(), end];
    }

    // 6. Africa <-> Europe
    if (pair === 'africa-europe') {
        let p = [];
        if (sR === 'africa') {
            if (sLat < -30) p.push(WAYPOINTS.namibiaCoast.coords);
            p.push(WAYPOINTS.westAfricaCoast.coords, WAYPOINTS.gibraltar.coords);
            if (eLat > 45) p.push(WAYPOINTS.portugalWest.coords, WAYPOINTS.dover.coords);
            return [start, ...p, end];
        } else {
            if (sLat > 45) p.push(WAYPOINTS.dover.coords, WAYPOINTS.portugalWest.coords);
            p.push(WAYPOINTS.gibraltar.coords, WAYPOINTS.westAfricaCoast.coords);
            if (eLat < -30) p.push(WAYPOINTS.namibiaCoast.coords);
            return [start, ...p, end];
        }
    }

    return [start, end];
}

// --- MODULE: ECONOMY & LOGISTICS ENGINE ---
function gameLoop(timestamp) {
    if (!state.lastTick) state.lastTick = timestamp;
    const dt = (timestamp - state.lastTick) / 1000;
    state.lastTick = timestamp;

    updateParticles(dt);
    
    // Update system notifications life
    for (let i = state.notifications.length - 1; i >= 0; i--) {
        state.notifications[i].life -= dt;
        if (state.notifications[i].life <= 0) state.notifications.splice(i, 1);
    }

    if (state.speed > 0) {
        const gameDt = dt * state.speed;
        updateEconomy(gameDt); 
        updateUnits(gameDt); 
        updateEvents(gameDt);
    }
    
    // Smooth UI Updates
    state.uiTimer = (state.uiTimer || 0) + dt;
    if (state.uiTimer > 0.2) { 
        try {
            updateUI(); 
            updateDashboard(); 
            renderHistoryCharts(); 
        } catch (e) {
            console.warn("UI Update Error:", e);
        }
        state.uiTimer = 0; 
    }

    render();
    requestAnimationFrame(gameLoop);
}

function updateEvents(dt) {
    state.events.forEach(e => e.timeLeft -= dt);
    state.events = state.events.filter(e => e.timeLeft > 0);

    // Generation frequency adjusted for longer durations
    if (Math.random() < CONFIG.gameplay.eventFrequency * dt) { 
        const rand = Math.random();
        if (rand < 0.4) { // Market Spike (Positive)
            const target = state.nodes.filter(n => n.type === 'market')[Math.floor(Math.random() * 3)];
            if (target) {
                state.events.push({ id: `spike-${Date.now()}`, type: 'market_spike', targetId: target.id, magnitude: 2.5, timeLeft: 150.0, label: `${target.name} Demand Spike`, color: '#ffd700', icon: 'üî•' });
                spawnParticle(state.projection(target.coords), "BOOM!", "#ffd700");
            }
        } else if (rand < 0.7) { // Production Crisis (Negative)
            const target = state.nodes.filter(n => n.type === 'supply')[Math.floor(Math.random() * 3)];
            if (target) {
                state.events.push({ id: `disrupt-${Date.now()}`, type: 'prod_crisis', targetId: target.id, magnitude: 0.2, timeLeft: 120.0, label: `${target.name} Operation Halted`, color: '#f85149', icon: '‚ö†Ô∏è' });
                spawnParticle(state.projection(target.coords), "CRISIS!", "#f85149");
            }
        } else { // Route Disruption (Negative)
            const activeRoutes = state.routes.filter(r => r.active);
            if (activeRoutes.length > 0) {
                const target = activeRoutes[Math.floor(Math.random() * activeRoutes.length)];
                const fromNode = state.nodes.find(n => n.id === target.from);
                const toNode = state.nodes.find(n => n.id === target.to);
                state.events.push({ 
                    id: `route-${Date.now()}`, 
                    type: 'route_clog', 
                    targetId: target.id, 
                    magnitude: 5.0, 
                    timeLeft: 100.0, 
                    label: `${fromNode.name}‚Üí${toNode.name} Slowdown`, 
                    color: '#f85149', 
                    icon: '‚öì' 
                });
            }
        }
    }
}

function updateEconomy(dt) {
    const dayInc = dt / CONFIG.gameplay.dayDuration;
    state.day += dayInc;

    if (state.day >= 365) { 
        state.day = 365;
        if (state.currentYear >= state.durationYears) endGame(); 
        else showYearlyReport();
        return; 
    }

    document.getElementById('time-display').innerText = `Day ${state.day.toFixed(1)}`; 
    
    // Day-based history and stats
    if (Math.floor(state.day) > state.lastIntegerDay) { 
        state.lastIntegerDay = Math.floor(state.day);
        recordHistory();
    }

    const dailyToPerSec = 1.0 / CONFIG.gameplay.dayDuration;

    state.nodes.forEach(node => {
        if (node.alert > 0) node.alert -= dt;

        // Apply storage costs
        if (node.inventory > 0.1) { // Only track storage if there is meaningful inventory
            const storageCostTotal = node.inventory * CONFIG.storageCostPerUnit * dailyToPerSec * dt;
            state.cash -= storageCostTotal;
            node.costs.storage += storageCostTotal / node.inventory;
            node.unitCost = Object.values(node.costs).reduce((a, b) => a + b, 0);
        } else if (node.inventory <= 0.01) {
            // Reset storage cost component if inventory is practically zero
            node.costs.storage = 0;
        }

        if (node.type === 'supply') {
            const prodEvent = state.events.find(e => e.targetId === node.id && e.type === 'prod_crisis');
            const prodMult = prodEvent ? prodEvent.magnitude : 1.0;
            
            // Smart Throttling: Check downstream capacity
            let downstreamFull = false;
            const downstreamRoutes = state.routes.filter(r => r.from === node.id && r.active);
            if (downstreamRoutes.length > 0) {
                const avgDownstreamFill = downstreamRoutes.reduce((acc, r) => {
                    const dest = state.nodes.find(n => n.id === r.to);
                    return acc + (dest.inventory / dest.maxInventory);
                }, 0) / downstreamRoutes.length;
                if (avgDownstreamFill > 0.9) downstreamFull = true;
            }

            const room = node.maxInventory - node.inventory;
            const potentialProd = node.production * prodMult * dailyToPerSec * dt * (downstreamFull ? 0.2 : 1.0);
            const actualProd = Math.min(potentialProd, room);
            
            // Apply Automation Discount
            const automationFactor = Math.pow(CONFIG.investment.automation.costReduction, (node.levels.automation - 1));
            const rawCost = (node.baseCosts.raw || 0) * automationFactor; // Ensure baseCosts.raw is used
            
            if (actualProd > 0 && state.cash > -10000) {
                // BUG FIX: Charge only the raw material cost
                state.cash -= actualProd * rawCost;
                node.inventory += actualProd;
                
                // Update node's raw cost tracking for display
                node.costs.raw = rawCost; 
            }
        }

        if (node.type === 'make') {
            const room = node.maxInventory - node.inventory;
            const potentialProd = node.processRate * dailyToPerSec * dt;
            
            // BOM Check: How many can we actually make based on available components?
            let maxByBOM = potentialProd;
            if (node.bom) {
                for (const [resource, amountNeeded] of Object.entries(node.bom)) {
                    const available = (node.inputs && node.inputs[resource]) ? node.inputs[resource] : 0;
                    const possibleWithThisResource = available / amountNeeded;
                    maxByBOM = Math.min(maxByBOM, possibleWithThisResource);
                }
            }
            
            const actualProd = Math.min(maxByBOM, room);
            
            if (actualProd > 0.001) {
                // Consume inputs
                if (node.bom) {
                    for (const [resource, amountNeeded] of Object.entries(node.bom)) {
                        node.inputs[resource] -= actualProd * amountNeeded;
                    }
                }
                node.inventory += actualProd;
                node.stalledDays = 0; // Reset stall counter
                
                // Show production particle occasionally
                if (Math.random() < 0.02) {
                    spawnParticle(state.projection(node.coords), "‚öôÔ∏è", "#f59e0b");
                }
            } else if (potentialProd > 0.1 && maxByBOM < 0.1 && room > 10) {
                 // Stalled due to missing components (Synchronization Risk)
                 node.stalledDays = (node.stalledDays || 0) + dayInc;
                 if (Math.random() < 0.01) node.alert = 2.0;
            }
        }
        
        // Apply Quality Investment Effect
        const qualityLevel = node.levels.quality || 1;
        const qualityFactor = Math.pow(CONFIG.investment.quality.decayReduction, (qualityLevel - 1));
        const baseDecay = node.baseQualityDecay || (node.type === 'market' ? CONFIG.gameplay.qualityDecayMarket : CONFIG.gameplay.qualityDecaySupply);
        const decayRate = baseDecay * qualityFactor;
        
        if (node.inventory > 0) node.quality = Math.max(0.1, node.quality - dt * decayRate);

        if (node.type === 'market') {
            const spikeEvent = state.events.find(e => e.targetId === node.id && e.type === 'market_spike');
            const spikeMult = spikeEvent ? spikeEvent.magnitude : 1.0;
            node.demand = node.baseDemand * (1 + Math.sin(node.phase + Date.now()/2000) * 0.3) * spikeMult;
            
            // Dampen quality impact on price: Range 0.8x to 1.2x of salePrice
            const price = CONFIG.salePrice * (0.8 + 0.4 * Math.pow(node.quality, 2)) * spikeMult;
            const sell = Math.min(node.inventory, node.demand * dailyToPerSec * dt);
            
            if (sell > 0) { 
                node.inventory -= sell; 
                state.cash += sell * price; 
                state.totalSales += sell; 
                state.yearlySales += sell; 
                if (Math.random() < 0.05) {
                     let color = node.quality > 0.8 ? '#3fb950' : (node.quality > 0.5 ? '#dbab09' : '#f85149');
                     spawnParticle(state.projection(node.coords), `+$${Math.floor(sell*price)}`, color); 
                }
            } else if (node.demand > 0 && node.inventory < 1) {
                const missed = node.demand * dailyToPerSec * dt;
                state.totalLostSales += missed;
                state.yearlyLostSales += missed;
                state.totalLostRevenue += missed * price;
                state.yearlyLostRevenue += missed * price;
                if (Math.random() < 0.02) node.alert = 3.0;
            }
        }
    });
    
    updateLogistics(dt);
}

function recordHistory() {
    const totalInv = state.nodes.reduce((a,n) => a + n.inventory, 0);
    const totalDemand = state.nodes.filter(n => n.type === 'market').reduce((a,n) => a + n.demand, 0);
    const totalRaw = state.nodes.filter(n => n.type === 'supply').reduce((a,n) => a + n.production, 0);
    const totalFactory = state.nodes.filter(n => n.type === 'make').reduce((a,n) => a + n.processRate, 0);
    const totalProd = Math.min(totalRaw, totalFactory);

    // Calculate Avg Margin % only at markets with inventory
    const activeMarkets = state.nodes.filter(n => n.type === 'market' && n.inventory > 1);
    const avgMargin = activeMarkets.length > 0 ? activeMarkets.reduce((acc, m) => {
        const spike = (state.events || []).find(e => e.targetId === m.id && e.type === 'market_spike');
        const price = CONFIG.salePrice * (0.8 + 0.4 * Math.pow(m.quality, 2)) * (spike ? spike.magnitude : 1);
        const margin = price > 0 ? (price - m.unitCost) / price : 0;
        return acc + margin;
    }, 0) / activeMarkets.length : 0;

    const globalDay = ((state.currentYear - 1) * 365) + state.day;
    state.history.days.push(globalDay);
    state.history.cash.push(state.cash);
    state.history.inventory.push(totalInv);
    state.history.demand.push(totalDemand);
    state.history.production.push(totalProd);
    state.history.margin.push(avgMargin * 100);
    
    if (state.history.days.length > 50) {
        state.history.days.shift(); 
        state.history.cash.shift(); 
        state.history.inventory.shift(); 
        state.history.demand.shift(); 
        state.history.production.shift();
        state.history.margin.shift();
    }
}

function updateLogistics(dt) {
    state.routes.forEach(route => { 
        if (route.active) { 
            let tickRate = 1.0;
            const clogEvent = state.events.find(e => e.targetId === route.id && e.type === 'route_clog');
            const toNode = state.nodes.find(n => n.id === route.to);
            
            if (clogEvent) {
                tickRate = 1.0 / clogEvent.magnitude;
            } else if (route.type === 'air' && toNode.type === 'market') {
                const isSpiking = state.events.some(e => e.targetId === toNode.id && e.type === 'market_spike');
                if (isSpiking) tickRate = 20.0; 
                else if (toNode.inventory < toNode.maxInventory * 0.15) tickRate = 5.0; 
            }

            route.timer += dt * 1000 * tickRate; 
            if (route.timer >= route.interval) { 
                route.timer = 0; 
                dispatchUnit(route); 
            } 
        } 
    });
}

function dispatchUnit(route) {
    const from = state.nodes.find(n => n.id === route.from);
    const to = state.nodes.find(n => n.id === route.to);
    const cfg = CONFIG.transport[route.type];
    
    const incomingCargo = state.units
        .filter(u => {
             const r = state.routes.find(r => r.id === u.routeId);
             return r && r.to === to.id;
        })
        .reduce((sum, u) => sum + u.cargo, 0);

    if (to.inventory + incomingCargo >= to.maxInventory) {
        return;
    }

    let amount = Math.min(cfg.capacity, from.inventory);
    
    // Efficiency check: ships should only move if they have a decent load
    const minLoad = route.type === 'ship' ? 100 : 10;
    
    if (amount >= minLoad && state.cash >= -5000) { // Allow slight debt for dispatching
        from.inventory -= amount; 
        
        const totalDispatchCost = cfg.costPerDispatch + (amount * cfg.costPerUnit);
        state.cash -= totalDispatchCost;
        
        const transportCostPerUnit = totalDispatchCost / amount;
        const unitCosts = { ...from.costs };
        unitCosts.transport += transportCostPerUnit;

        const resourceType = from.type === 'supply' ? from.resourceType : 'battery';

        state.units.push({ 
            routeId: route.id, 
            type: route.type, 
            resourceType: resourceType,
            pathCoords: route.pathCoords, 
            progress: 0, 
            cargo: amount,
            quality: from.quality,
            costs: unitCosts,
            unitCost: Object.values(unitCosts).reduce((a, b) => a + b, 0)
        });
    }
}

function updateUnits(dt) {
    for (let i = state.units.length - 1; i >= 0; i--) {
        const u = state.units[i];
        const route = state.routes.find(r => r.id === u.routeId);
        if (!route) continue;

        let speedPx = CONFIG.transport[u.type].speed * 0.04;
        
        // Apply slowdown if there is a clog event on this route
        const clogEvent = state.events.find(e => e.targetId === route.id && e.type === 'route_clog');
        if (clogEvent) {
            speedPx /= clogEvent.magnitude; // Slow down movement speed
        }

        const dist = Math.max(1, route.totalVisualDistance);
        u.progress += (speedPx * dt) / dist;

        u.quality = Math.max(0.1, u.quality - dt * 0.001);

        if (u.progress >= 1) {
            const dest = state.nodes.find(n => n.id === route.to);
            if (dest.type === 'make') {
                // Apply Automation Discount for Manufacturing
                const automationLevel = dest.levels ? dest.levels.automation : 1;
                const automationFactor = Math.pow(CONFIG.investment.automation.costReduction, (automationLevel - 1));
                const baseMakeCost = dest.id === 'china' ? 8.0 : (dest.id === 'vietnam' ? 6.0 : 10.0);
                const makeCost = baseMakeCost * automationFactor;
                
                u.costs.make += makeCost;
                u.unitCost = Object.values(u.costs).reduce((a, b) => a + b, 0);
                
                // Update make cost tracking
                dest.costs.make = makeCost;
                state.cash -= u.cargo * makeCost; 
            }

            // Phase 4: Refined stock calculation for merging quality/costs
            const currentStockForMerge = (dest.type === 'make' && dest.inputs) 
                ? (Object.values(dest.inputs).reduce((a, b) => a + b, 0) + dest.inventory)
                : dest.inventory;
            const totalStockForMerge = currentStockForMerge + u.cargo;

            if (totalStockForMerge > 0) {
                dest.quality = ((currentStockForMerge * dest.quality) + (u.cargo * u.quality)) / totalStockForMerge;
                
                // Merge detailed costs
                Object.keys(dest.costs).forEach(key => {
                    dest.costs[key] = ((currentStockForMerge * (dest.costs[key] || 0)) + (u.cargo * (u.costs[key] || 0))) / totalStockForMerge;
                });
                dest.unitCost = Object.values(dest.costs).reduce((a, b) => a + b, 0);
            }
            
            if (dest.type === 'make' && dest.inputs && dest.inputs[u.resourceType] !== undefined) {
                dest.inputs[u.resourceType] += u.cargo;
            } else {
                dest.inventory += u.cargo;
            }
            state.units.splice(i, 1);
        }
    }
}

function updateParticles(dt) {
    for (let i = state.particles.length - 1; i >= 0; i--) {
        state.particles[i].life -= dt; state.particles[i].y -= 10 * dt;
        if (state.particles[i].life <= 0) state.particles.splice(i, 1);
    }
}

function spawnParticle(pos, text, color) { 
    state.particles.push({ x: pos[0], y: pos[1] - 10, text, color, life: 1.5 }); 
}

// --- MODULE: RENDERER ---
let renderErrorShown = false;
function render() {
    try {
        const { ctx, width, height, transform, routes, units, nodes, particles, events } = state;
        ctx.clearRect(0, 0, width, height);
        
        ctx.save();
        ctx.translate(transform.x, transform.y);
        ctx.scale(transform.k, transform.k);
        
        // 1. Draw Routes
        routes.forEach(r => {
            const hasUnits = units.some(u => u.routeId === r.id);
            if (!r.active && !hasUnits) return;
            
            const clogEvent = events.find(e => e.targetId === r.id && e.type === 'route_clog');
            
            ctx.beginPath();
            state.pathGenerator.context(ctx)({type: "LineString", coordinates: r.pathCoords});
            
            let baseColor = r.type === 'air' ? CONFIG.colors.airPath : CONFIG.colors.seaPath;
            let lineWidth = (r.type === 'air' ? 1.5 : 2) / transform.k;
            
            if (clogEvent) {
                baseColor = '#f85149';
                lineWidth *= 2.5;
                // Add a glowing effect for the clog
                ctx.shadowBlur = 10 / transform.k;
                ctx.shadowColor = '#f85149';
            }
            
            ctx.strokeStyle = baseColor;
            ctx.lineWidth = lineWidth;
            
            if (r.type === 'air') ctx.setLineDash([4/transform.k, 6/transform.k]);
            ctx.stroke(); 
            ctx.setLineDash([]);
            ctx.shadowBlur = 0; // Reset shadow
            
            state.pathGenerator.context(null); 
        });

        // 2. Draw Units
        units.forEach(u => {
            const route = routes.find(r => r.id === u.routeId);
            if (!route || !route.visualStops || route.visualStops.length < 2) return;

            const stops = route.visualStops;
            let idx = stops.findIndex(s => s > u.progress);
            if (idx === -1) idx = stops.length - 1;
            idx = Math.max(1, idx) - 1;
            
            if (idx < 0 || idx >= route.pathCoords.length - 1) return;

            const startP = stops[idx];
            const endP = stops[idx+1];
            if (startP === undefined || endP === undefined) return;

            const range = endP - startP;
            const t = range > 0 ? (u.progress - startP) / range : 0;
            
            const interpolator = d3.geoInterpolate(route.pathCoords[idx], route.pathCoords[idx+1]);
            const pos = interpolator(t);
            const p = state.projection(pos);
                
            if (p) {
                const [x, y] = p;
                ctx.fillStyle = u.type === 'ship' ? CONFIG.transport.ship.color : CONFIG.transport.air.color;
                ctx.beginPath();
                if (u.type === 'ship') {
                    const s = 4/transform.k;
                    ctx.rect(x - s, y - s, s * 2, s * 2);
                } else {
                    const s = 5/transform.k;
                    ctx.moveTo(x, y - s);
                    ctx.lineTo(x + s, y + s);
                    ctx.lineTo(x - s, y + s);
                }
                ctx.fill();
            }
        });

        // 3. Draw Nodes
        nodes.forEach(n => {
            const [x, y] = state.projection(n.coords);
            const isSel = state.selectedNodeId === n.id;
            const r = (isSel ? 14 : 9) / transform.k;
            
            // Unified Event Effect
            const activeEvent = events.find(e => e.targetId === n.id);
            if (activeEvent && !n.locked) {
                 const t = (Date.now() / 300) % 1;
                 ctx.beginPath();
                 ctx.arc(x, y, r + (30 * t)/transform.k, 0, Math.PI * 2);
                 ctx.strokeStyle = activeEvent.color + Math.floor((1-t)*255).toString(16).padStart(2,'0'); 
                 ctx.lineWidth = 4/transform.k; 
                 ctx.stroke();
            }

            if (n.alert > 0 && !n.locked) {
                const t = (Date.now() / 800) % 1;
                ctx.beginPath(); 
                ctx.arc(x, y, r + (20 * t)/transform.k, 0, Math.PI * 2); 
                ctx.fillStyle = `rgba(248, 81, 73, ${0.4 * (1-t)})`; ctx.fill();
                ctx.strokeStyle = `rgba(248, 81, 73, ${1-t})`; ctx.lineWidth = 2/transform.k; ctx.stroke();
            }

            // Draw Node Body
            ctx.beginPath(); 
            ctx.arc(x, y, r, 0, Math.PI * 2); 
            
            if (n.locked) {
                // Locked Node Style
                ctx.fillStyle = "rgba(48, 54, 61, 0.4)"; 
                ctx.fill();
                ctx.strokeStyle = "#8b949e"; 
                ctx.lineWidth = 2/transform.k; 
                ctx.setLineDash([4/transform.k, 4/transform.k]);
                ctx.stroke();
                ctx.setLineDash([]);
                
                // Draw Lock Icon
                ctx.fillStyle = "#8b949e";
                ctx.font = `bold ${10/transform.k}px Inter`;
                ctx.textAlign = "center";
                ctx.textBaseline = "middle";
                ctx.fillText("üîí", x, y);
            } else {
                // Active Node Style
                ctx.fillStyle = CONFIG.colors[n.type]; 
                ctx.fill();
                
                if (isSel) {
                     ctx.strokeStyle = '#fff'; ctx.lineWidth = 3/transform.k; ctx.stroke();
                } else {
                     ctx.strokeStyle = '#161b22'; ctx.lineWidth = 2/transform.k; ctx.stroke();
                }

                const bw = 32/transform.k, bh = 5/transform.k, pct = Math.min(1, n.inventory / n.maxInventory);
                ctx.fillStyle = "rgba(22, 27, 34, 0.8)"; ctx.fillRect(x - bw/2, y + r + 2/transform.k, bw, bh);
                ctx.fillStyle = pct < 0.2 ? CONFIG.colors.supply : CONFIG.colors.market; ctx.fillRect(x - bw/2, y + r + 2/transform.k, bw * pct, bh);
            }
        });

        // 4. Draw Particles
        particles.forEach(p => { 
            ctx.globalAlpha = Math.max(0, p.life); 
            ctx.font = `bold ${14/transform.k}px Inter`; 
            ctx.fillStyle = p.color; 
            ctx.fillText(p.text, p.x, p.y); 
            ctx.globalAlpha = 1; 
        });
        ctx.restore();
    } catch (e) {
        if (!renderErrorShown) {
            console.error(e);
            renderErrorShown = true;
        }
    }
}

// --- MODULE: UI MANAGER ---
function showNotification(text, color = 'var(--accent-blue)') {
    state.notifications.push({ text, color, life: 4.0 });
    // Limit active notifications
    if (state.notifications.length > 3) state.notifications.shift();
}

function updateUI() {
    try {
        const cashEl = document.getElementById('cash-display');
        if (cashEl) cashEl.innerText = Utils.fmtCurrency(state.cash);
        
        if (state.selectedNodeId) {
            const node = state.nodes.find(n => n.id === state.selectedNodeId);
            if (node) updateSheetStats(node);
        }

        const area = document.getElementById('notification-area');
        if (!area) return;
    
    // Combine events and notifications for display
    const eventToasts = state.events.map(e => `
        <div class="toast info" style="opacity:1; transform:none; animation:none; border-bottom: 2px solid ${e.color}; width: fit-content;">
            <span class="toast-icon">${e.icon}</span><span><strong>${e.label}</strong> (${(e.timeLeft * 0.2).toFixed(1)}d)</span>
        </div>
    `);

    const notifyToasts = state.notifications.map(n => `
        <div class="toast info" style="opacity:1; transform:none; animation:none; border-bottom: 2px solid ${n.color}; width: fit-content;">
            <span class="toast-icon">‚ÑπÔ∏è</span><span>${n.text}</span>
        </div>
    `);

    // Limit to 4 total toasts
    area.innerHTML = [...eventToasts, ...notifyToasts].slice(0, 4).join('');
    } catch (e) {
        console.warn("UI Update Error:", e);
    }
}

d3.select("#map-svg").on("click", (event) => {
    const [mx, my] = d3.pointer(event);
    const tx = (mx - state.transform.x) / state.transform.k;
    const ty = (my - state.transform.y) / state.transform.k;
    const clicked = state.nodes.find(n => { 
        const [nx, ny] = state.projection(n.coords); 
        return Math.hypot(nx - tx, ny - ty) < 25/state.transform.k; 
    });
    if (clicked) openSheet(clicked); else closePanel();
});

function openSheet(node) {
    if (!node) return;
    try {
        state.selectedNodeId = node.id;
        const s = document.getElementById('selection-sheet');
        if (!s) return;
        
        const titleEl = document.getElementById('sheet-title');
        if (titleEl) {
            titleEl.innerText = node.name;
            titleEl.style.color = CONFIG.colors[node.type];
        }

    const isMobileLandscape = window.innerWidth > window.innerHeight && window.innerHeight <= 500;
    const isDesktop = window.innerWidth >= 900; 

    s.classList.remove('panel-left', 'panel-right');

    if (isMobileLandscape || isDesktop) {
        const [nx, ny] = state.projection(node.coords);
        const tx = nx * state.transform.k + state.transform.x;

        if (tx < window.innerWidth / 2) s.classList.add('panel-right'); 
        else s.classList.add('panel-left'); 
        
        s.style.position = 'fixed';
        s.style.width = '40%';
        s.style.minWidth = '300px';
        s.style.top = '0';
        s.style.height = '100vh';
        s.style.maxHeight = '100vh';
        s.style.borderRadius = '0';
        s.style.zIndex = '1000';

        if (s.classList.contains('panel-left')) {
            s.style.left = '0'; s.style.right = 'auto';
            s.style.borderRight = '1px solid var(--panel-border)'; s.style.borderLeft = 'none';
        } else {
            s.style.right = '0'; s.style.left = 'auto';
            s.style.borderLeft = '1px solid var(--panel-border)'; s.style.borderRight = 'none';
        }
    } else {
        s.style.position = 'absolute'; s.style.width = '100%'; s.style.minWidth = 'auto'; 
        s.style.top = 'auto'; s.style.height = 'auto'; s.style.maxHeight = '85vh';
        s.style.borderRadius = '24px 24px 0 0'; s.style.zIndex = '100';
        s.style.left = '0'; s.style.right = '0'; s.style.bottom = '0';
        s.style.borderTop = '1px solid var(--panel-border)';
    }

    updateSheetStats(node);
    renderSheetRoutes(node);
    s.classList.add('active');
    } catch (e) {
        console.error("Error opening sheet:", e);
    }
}

function updateSheetStats(n) {
    if (!n) return;
    try {
        const container = document.getElementById('sheet-stats');
        if (!container) return;
        
        // Calculate costs for each investment type
        const getCost = (type) => {
            const base = CONFIG.investment[type].cost;
            const lvl = (n.levels && n.levels[type]) ? n.levels[type] : 1;
            return Math.floor(base * Math.pow(CONFIG.upgradeCosts.multiplier, lvl - 1));
        };
        
        const costs = {
            production: getCost('production'),
            quality: getCost('quality'),
            automation: getCost('automation')
        };
        
        if (container.getAttribute('data-node-id') !== n.id) {
            container.setAttribute('data-node-id', n.id);
            
            // LOCKED NODE UI
            if (n.locked) {
                const cost = n.unlockCost;
                const canAfford = state.cash >= cost;
                
                let h = `<div class="stat-card" style="grid-column: span 2; padding:20px; text-align:center; background:rgba(255,255,255,0.02);">
                    <div style="font-size:14px; color:var(--text-secondary); margin-bottom:12px; text-transform:uppercase; letter-spacing:1px;">New Hub Opportunity</div>
                    <div style="font-size:24px; font-weight:bold; color:var(--text-primary); margin-bottom:8px;">${n.name}</div>
                    <div style="font-size:12px; color:var(--text-secondary); margin-bottom:20px;">
                        Type: <span style="color:${CONFIG.colors[n.type]}; font-weight:bold;">${n.type.toUpperCase()}</span><br>
                        Potential: ${n.type === 'market' ? n.baseDemand + ' Demand/day' : (n.type === 'supply' ? n.production + ' Prod/day' : n.capacity + ' Capacity')}
                    </div>
                    <div style="font-size:32px; font-weight:800; color:${canAfford ? 'var(--accent-green)' : 'var(--text-secondary)'}; margin-bottom:20px;">
                        ${Utils.fmtCurrency(cost)}
                    </div>
                    <button onclick="unlockNode('${n.id}')" style="
                        width:100%; padding:16px; border:none; border-radius:12px; font-size:16px; font-weight:bold;
                        background:${canAfford ? 'var(--accent-green)' : '#30363d'}; 
                        color:white; cursor:${canAfford ? 'pointer' : 'not-allowed'}; opacity:${canAfford ? 1 : 0.5};
                        box-shadow: ${canAfford ? '0 4px 12px rgba(63, 185, 80, 0.4)' : 'none'};
                    ">BUILD HUB</button>
                </div>`;
                container.innerHTML = h;
                
                // Hide route section for locked nodes
                const rSec = document.querySelector('.routes-section');
                if (rSec) rSec.style.display = 'none';
                return;
            }

            // UNLOCKED NODE UI (Existing logic)
            // Build specialized investment UI
            let invHTML = `<div class="stat-card" style="grid-column: span 2; display:flex; flex-direction:column; gap:8px;">
                <div class="stat-card-label" style="margin-bottom:4px;">Strategic Investments</div>`;
            
            ['production', 'quality', 'automation'].forEach(type => {
                const cfg = CONFIG.investment[type];
                const lvl = (n.levels && n.levels[type]) ? n.levels[type] : 1;
                invHTML += `<div style="display:flex; justify-content:space-between; align-items:center; background:rgba(255,255,255,0.05); padding:6px 10px; border-radius:6px;">
                    <div style="display:flex; flex-direction:column;">
                        <span style="font-size:12px; font-weight:bold;">${cfg.label} <span style="font-weight:normal; opacity:0.7;" id="lvl-${type}">Lv.${lvl}</span></span>
                        <span style="font-size:10px; color:var(--text-secondary);" id="roi-${type}">ROI: Calc...</span>
                    </div>
                    <button id="btn-${type}" onclick="investNode('${n.id}', '${type}')" style="border:none; padding:4px 12px; border-radius:4px; font-size:11px; font-weight:bold; cursor:pointer;">${Utils.fmtCurrency(costs[type])}</button>
                </div>`;
            });
            invHTML += `</div>`;

            let h = invHTML;
            h += `<div class="stat-card" style="grid-column: span 2;">
                    <div class="stat-card-label">Cost-to-Serve Breakdown</div>
                    <div style="display:flex; flex-direction:column; gap:4px; margin-top:8px;">
                        <div style="display:flex; justify-content:space-between; font-size:12px;"><span>Raw Material</span><span id="cost-raw">$0.00</span></div>
                        <div style="display:flex; justify-content:space-between; font-size:12px;"><span>Transport</span><span id="cost-transport">$0.00</span></div>
                        <div style="display:flex; justify-content:space-between; font-size:12px;"><span>Processing</span><span id="cost-make">$0.00</span></div>
                        <div style="display:flex; justify-content:space-between; font-size:12px;"><span>Storage/Carry</span><span id="cost-storage">$0.00</span></div>
                        <div style="display:flex; justify-content:space-between; font-size:13px; font-weight:bold; border-top:1px solid rgba(255,255,255,0.1); padding-top:4px; margin-top:2px;"><span>Total Unit Cost</span><span id="cost-total">$0.00</span></div>
                    </div>
                  </div>`;
            h += `<div class="stat-card"><div class="stat-card-label">Stock Level</div><div class="stat-card-value"><span id="stat-stock">${Math.floor(n.inventory)}</span> / <span id="stat-max">${Math.floor(n.maxInventory)}</span></div></div>`;
            h += `<div class="stat-card"><div class="stat-card-label">Net Flow</div><div class="stat-card-value" id="stat-flow">0 /d</div></div>`;
            
            if (n.type === 'market') {
                h += `<div class="stat-card"><div class="stat-card-label">Freshness</div><div class="stat-card-value"><span id="stat-fresh-val">0%</span> <span id="stat-fresh-text" style="font-size:12px; opacity:0.8">-</span></div></div>`;
                h += `<div class="stat-card"><div class="stat-card-label">Price</div><div class="stat-card-value" style="color:var(--accent-green)"><span id="stat-price-val">$0</span></div></div>`;
                h += `<div class="stat-card"><div class="stat-card-label">Demand</div><div class="stat-card-value" style="color:var(--accent-green)"><span id="stat-rate">${n.demand.toFixed(1)}</span> /d</div></div>`;
            }
            else h += `<div class="stat-card"><div class="stat-card-label">Rate</div><div class="stat-card-value"><span id="stat-rate">${(n.type==='supply'?n.production:n.processRate).toFixed(1)}</span> /d</div></div>`;
            
            if (n.type === 'make' && n.inputs) {
                let inputHTML = `<div class="stat-card" style="grid-column: span 2;">
                    <div class="stat-card-label">BOM Components (Inventory)</div>
                    <div style="display:flex; flex-direction:column; gap:6px; margin-top:8px;" id="stat-inputs">`;
                for (const [res, amount] of Object.entries(n.inputs)) {
                    const color = CONFIG.colors[res] || 'var(--text-primary)';
                    inputHTML += `<div style="display:flex; justify-content:space-between; font-size:12px;">
                        <span style="color:${color}; font-weight:bold;">${res.toUpperCase()}</span>
                        <span><span id="stat-input-${res}">${Math.floor(amount)}</span> units</span>
                    </div>`;
                }
                
                // Add Stalled Status
                const isStalled = n.stalledDays > 0.1;
                inputHTML += `<div style="margin-top:10px; padding-top:8px; border-top:1px solid rgba(255,255,255,0.1); display:flex; justify-content:space-between; align-items:center;">
                    <span style="font-size:11px; color:var(--text-secondary);">Sync Status:</span>
                    <span id="stat-stall-status" style="font-size:12px; font-weight:bold; color:${isStalled ? 'var(--accent-red)' : 'var(--accent-green)'}">
                        ${isStalled ? `STALLED (${n.stalledDays.toFixed(1)}d)` : 'OPERATIONAL'}
                    </span>
                </div>`;

                inputHTML += `</div></div>`;
                h += inputHTML;
            }

            container.innerHTML = h;
        }

        // Update Dynamic values
        if (n.type === 'make' && n.inputs) {
            for (const [res, amount] of Object.entries(n.inputs)) {
                const el = document.getElementById(`stat-input-${res}`);
                if (el) el.innerText = Math.floor(amount);
            }
            const stallEl = document.getElementById('stat-stall-status');
            if (stallEl) {
                const isStalled = n.stalledDays > 0.1;
                stallEl.innerText = isStalled ? `STALLED (${n.stalledDays.toFixed(1)}d)` : 'OPERATIONAL';
                stallEl.style.color = isStalled ? 'var(--accent-red)' : 'var(--accent-green)';
            }
        }

        // Update Buttons and ROI
        ['production', 'quality', 'automation'].forEach(type => {
            const cost = costs[type];
            const btn = document.getElementById(`btn-${type}`);
            const lvlEl = document.getElementById(`lvl-${type}`);
            const roiEl = document.getElementById(`roi-${type}`);
            
            if (lvlEl) lvlEl.innerText = `Lv.${(n.levels && n.levels[type]) ? n.levels[type] : 1}`;
            
            if (btn) {
                btn.innerText = Utils.fmtCurrency(cost); // Fixed: Removed duplicate '$'
                btn.style.background = state.cash >= cost ? 'var(--accent-blue)' : '#30363d';
                btn.style.opacity = state.cash >= cost ? 1 : 0.5;
                btn.style.color = 'white';
            }
            
            // ROI Calculation Logic
            if (roiEl) {
                let savingPerDay = 0;
                if (type === 'automation') {
                    // Savings from reduced Make/Raw costs based on current throughput
                    const throughput = n.type === 'market' ? n.demand : (n.type === 'supply' ? n.production : n.processRate);
                    const currentCost = (n.baseCosts.make || 0) + (n.baseCosts.raw || 0);
                    const discount = 1 - CONFIG.investment.automation.costReduction;
                    savingPerDay = throughput * currentCost * discount;
                } else if (type === 'quality') {
                    // Savings from reduced spoilage/price drop (approximate)
                    const stock = n.inventory;
                    const price = n.type === 'market' ? CONFIG.salePrice : n.unitCost;
                    savingPerDay = stock * 0.005 * price * 0.2; // Rough estimate of retained value
                } else if (type === 'production') {
                     // Profit from increased capacity (marginal profit * extra units)
                     const margin = 5; // Assumed margin per unit
                     const extraUnits = (n.type === 'supply' ? n.production : n.processRate) * 0.2;
                     savingPerDay = extraUnits * margin;
                }
                
                const roiDays = savingPerDay > 0 ? cost / savingPerDay : 999;
                const roiColor = roiDays < CONFIG.upgradeCosts.roiThreshold ? 'var(--accent-green)' : 'var(--text-secondary)';
                roiEl.innerText = roiDays < 999 ? `Recov: ${roiDays.toFixed(0)}d` : `Recov: Long`;
                roiEl.style.color = roiColor;
            }
        });
        
        // Cost Breakdown Values
        const rawEl = document.getElementById('cost-raw');
        if (rawEl) rawEl.innerText = '$' + (n.costs.raw || 0).toFixed(2);
        const transEl = document.getElementById('cost-transport');
        if (transEl) transEl.innerText = '$' + (n.costs.transport || 0).toFixed(2);
        const makeEl = document.getElementById('cost-make');
        if (makeEl) makeEl.innerText = '$' + (n.costs.make || 0).toFixed(2);
        const storEl = document.getElementById('cost-storage');
        if (storEl) storEl.innerText = '$' + (n.costs.storage || 0).toFixed(2);
        const totalEl = document.getElementById('cost-total');
        if (totalEl) totalEl.innerText = '$' + (n.unitCost || 0).toFixed(2);

        const stockEl = document.getElementById('stat-stock');
        if (stockEl) stockEl.innerText = Math.floor(n.inventory);
        const maxEl = document.getElementById('stat-max');
        if (maxEl) maxEl.innerText = Math.floor(n.maxInventory);

        // Calculate Net Flow
        let netFlow = 0;
        if (n.type === 'supply') netFlow = n.production;
        else if (n.type === 'make') netFlow = 0; // Balance of in/out
        else if (n.type === 'market') netFlow = -n.demand;

        state.routes.forEach(r => {
            if (!r.active) return;
            const flow = (CONFIG.transport[r.type].capacity / (r.interval / 1000));
            if (r.from === n.id) netFlow -= flow;
            if (r.to === n.id) netFlow += flow;
        });
        const flowEl = document.getElementById('stat-flow');
        if (flowEl) {
            flowEl.innerText = (netFlow > 0 ? '+' : '') + netFlow.toFixed(1) + '/d';
            flowEl.style.color = netFlow < -1 ? 'var(--accent-red)' : (netFlow > 5 ? 'var(--accent-yellow)' : 'var(--accent-green)');
        }
        
        const rateEl = document.getElementById('stat-rate');
        if (rateEl) rateEl.innerText = (n.type==='market'?n.demand:n.type==='supply'?n.production:n.processRate).toFixed(1);

        if (n.type === 'market') {
            const spike = (state.events || []).find(e => e.targetId === n.id && e.type === 'market_spike');
            const spikeMult = spike ? spike.magnitude : 1;
            const currentPrice = CONFIG.salePrice * (0.2 + 2.8 * Math.pow(n.quality, 2)) * spikeMult;
            const freshVal = document.getElementById('stat-fresh-val'), freshText = document.getElementById('stat-fresh-text'), priceVal = document.getElementById('stat-price-val');
            
            if (n.inventory < 1) {
                if (freshVal) freshVal.innerText = "-";
                if (freshText) freshText.innerText = "OUT OF STOCK";
                if (priceVal) priceVal.innerText = "-";
            } else {
                const q = n.quality;
                const qColor = q > 0.8 ? '#3fb950' : (q > 0.4 ? '#dbab09' : '#f85149');
                if (freshVal) { freshVal.innerText = (q*100).toFixed(0) + '%'; freshVal.parentElement.style.color = qColor; }
                if (freshText) freshText.innerText = q > 0.85 ? 'PREMIUM' : (q > 0.6 ? 'FRESH' : 'NORMAL');
                if (priceVal) priceVal.innerText = '$' + currentPrice.toFixed(1);
            }
        }

        const btn = document.getElementById('btn-upgrade'), card = document.getElementById('upgrade-card');
        if (btn) { btn.style.background = canAfford ? 'var(--accent-green)' : '#30363d'; btn.style.opacity = canAfford ? 1 : 0.5; }
        if (card) card.style.background = canAfford ? 'rgba(63, 185, 80, 0.15)' : 'rgba(255,255,255,0.05)';
    } catch (e) {
        console.warn("Panel Stats Error:", e);
    }
}

function renderSheetRoutes(n) {
    const section = document.querySelector('.routes-section');
    if (n.locked || n.type === 'market') { section.style.display = 'none'; return; }
    section.style.display = 'block';

    const c = document.getElementById('sheet-routes'), out = state.routes.filter(r => r.from === n.id);
    if (!out.length) { c.innerHTML = '<div style="color:var(--text-secondary); font-style:italic;">No outgoing routes.</div>'; return; }
    c.innerHTML = '';
    const iconAir = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polygon points="12 2 20 21 12 17 4 21 12 2"></polygon></svg>';
    const iconShip = '<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M2 21c.6.5 1.2 1 2.5 1 2.3 0 2.8-1 5-1 2.3 0 2.8 1 5 1 2.3 0 2.8-1 5-1 2.3 0 2.8 1 5 1 1.2 0 1.9-.5 2.5-1M2 21v-8c0-1.1.9-2 2-2h16c1.1 0 2 .9 2 2v8M12 11V3L9 6M12 3l3 3"/></svg>';

    [...new Set(out.map(r => r.to))].forEach(tid => {
        const tn = state.nodes.find(x => x.id === tid);
        // Don't show routes to locked nodes
        if (tn && tn.locked) return;
        
        const air = out.find(r => r.to === tid && r.type === 'air'), ship = out.find(r => r.to === tid && r.type === 'ship');
        const resourceName = n.type === 'supply' ? n.resourceType.toUpperCase() : 'BATTERY';
        const resourceColor = CONFIG.colors[n.type === 'supply' ? n.resourceType : 'battery'] || 'var(--text-primary)';

        c.innerHTML += `<div class="route-card">
            <div class="route-row" style="margin-bottom:8px;">
                <div style="display:flex; flex-direction:column;">
                    <span class="route-dest">To ${tn.name}</span>
                    <span style="font-size:10px; color:${resourceColor}; font-weight:bold; letter-spacing:0.5px;">${resourceName}</span>
                </div>
            </div>
            ${renderCommissionOpt(air, 'Air', iconAir, '$1.5k')}
            ${renderCommissionOpt(ship, 'Sea', iconShip, '$200')}
        </div>`;
    });
}

function renderCommissionOpt(r, l, i, c) {
    if (!r) return '';
    
    // Phase 3: Route Commissioning Logic
    if (!r.commissioned) {
        const canAfford = state.cash >= r.commissionCost;
        return `<div class="transport-option" style="flex-direction:column; align-items:flex-start; gap:8px; opacity:0.8; background:rgba(0,0,0,0.2); padding:8px; border-radius:6px; margin-top:4px;">
            <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                <div class="transport-info" style="color:var(--text-secondary);"><span>${i}</span><span>${l} (Closed)</span></div>
                <button onclick="commissionRoute('${r.id}')" style="
                    border:none; padding:4px 12px; border-radius:4px; font-size:11px; font-weight:bold; cursor:${canAfford?'pointer':'not-allowed'};
                    background:${canAfford?'var(--accent-blue)':'#30363d'}; color:white; opacity:${canAfford?1:0.5};
                ">OPEN ${Utils.fmtCurrency(r.commissionCost)}</button>
            </div>
        </div>`;
    }

    const intervalDays = (r.interval / CONFIG.gameplay.dayDuration / 1000).toFixed(1);
    const totalLead = (r.travelTimeDays || 0) + parseFloat(intervalDays);
    
    return `<div class="transport-option" style="flex-direction:column; align-items:flex-start; gap:8px;">
        <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
            <div class="transport-info"><span>${i}</span>
                <div style="display:flex; flex-direction:column;">
                    <span style="font-weight:500;">${l}</span>
                    <span style="font-size:10px; color:var(--text-secondary);">LT: <span style="font-weight:bold; color:var(--text-primary);" id="lt-${r.id}">${totalLead.toFixed(1)}d</span></span>
                </div>
                <span class="transport-cost">${c}</span>
            </div>
            <label class="switch" onclick="event.stopPropagation()"><input type="checkbox" ${r.active?'checked':''} onchange="toggleRoute('${r.id}')"><span class="slider"></span></label>
        </div>
        <div style="width:100%; display:${r.active?'flex':'none'}; align-items:center; gap:8px;" id="ctrl-${r.id}">
            <span style="font-size:11px; color:var(--text-secondary); white-space:nowrap;">Interval: <span id="val-${r.id}">${intervalDays}</span>d</span>
            <input type="range" min="0.5" max="30" step="0.5" value="${intervalDays}" style="flex:1" oninput="updateInterval('${r.id}', this.value)">
        </div>
    </div>`;
}

window.commissionRoute = (id) => {
    const r = state.routes.find(x => x.id === id);
    if (r && !r.commissioned && state.cash >= r.commissionCost) {
        state.cash -= r.commissionCost;
        r.commissioned = true;
        r.active = true; // Auto-activate on commission
        
        spawnParticle(state.projection(state.nodes.find(n => n.id === r.from).coords), "ROUTE OPEN!", "#58a6ff");
        showNotification(`New Route Opened to ${state.nodes.find(n => n.id === r.to).name}`, "#58a6ff");
        
        updateUI();
        // Refresh sheet
        const node = state.nodes.find(n => n.id === r.from);
        if (node) renderSheetRoutes(node);
    }
};

window.updateInterval = (id, val) => {
    const r = state.routes.find(x => x.id === id);
    if (r) { 
        r.interval = val * CONFIG.gameplay.dayDuration * 1000; 
        document.getElementById(`val-${id}`).innerText = val; 
        const ltEl = document.getElementById(`lt-${id}`);
        if (ltEl) {
            const totalLead = (r.travelTimeDays || 0) + parseFloat(val);
            ltEl.innerText = totalLead.toFixed(1) + 'd';
        }
    }
};

window.toggleRoute = id => { 
    const r = state.routes.find(x => x.id === id); 
    if(r) { r.active = !r.active; const ctrl = document.getElementById(`ctrl-${id}`); if(ctrl) ctrl.style.display = r.active ? 'flex' : 'none'; } 
};

window.setSpeed = val => { 
    const v = Number(val); state.speed = v; 
    const btns = document.querySelectorAll('.fab-menu .fab-btn');
    btns[0].classList.toggle('active', v >= 3); btns[1].classList.toggle('active', v === 1); btns[2].classList.toggle('active', v === 0);
    if (v >= 3) btns[0].innerText = `‚è© x${v}`; else btns[0].innerText = '‚è©';
};

window.cycleFastSpeed = () => {
    if (state.speed < 3) setSpeed(3); else if (state.speed === 3) setSpeed(10); else if (state.speed === 10) setSpeed(50); else setSpeed(3);
};

window.setDuration = (yrs) => {
    state.durationYears = yrs;
    ['1y', '3y', '5y'].forEach(id => document.getElementById(`btn-${id}`).classList.toggle('active', id === `${yrs}y`));
};

function showYearlyReport() {
    state.preReportSpeed = state.speed; // Remember current speed
    state.speed = 0;
    const rev = state.cash - state.yearlyCashStart;
    const totalPotential = state.yearlySales + state.yearlyLostSales;
    const serviceLevel = totalPotential > 0 ? state.yearlySales / totalPotential : 1.0;
    
    document.getElementById('report-year').innerText = state.currentYear;
    document.getElementById('report-revenue').innerText = Utils.fmtCurrency(rev);
    document.getElementById('report-service').innerText = (serviceLevel * 100).toFixed(0) + '%';
    document.getElementById('next-year').innerText = state.currentYear + 1;
    document.getElementById('report-modal').style.display = 'flex';
}

window.continueGame = () => {
    document.getElementById('report-modal').style.display = 'none';
    state.currentYear++;
    state.day = 1;
    state.lastIntegerDay = 1;
    state.yearlyCashStart = state.cash;
    state.yearlySales = 0;
    state.yearlyLostSales = 0;
    state.yearlyLostRevenue = 0;
    document.getElementById('year-display').innerText = `Year ${state.currentYear} / ${state.durationYears}`;
    setSpeed(state.preReportSpeed || 1); // Restore speed
};

window.adjustZoom = f => d3.select("#map-svg").transition().call(state.zoomBehavior.scaleBy, f);
window.resetZoom = () => d3.select("#map-svg").transition().call(state.zoomBehavior.transform, d3.zoomIdentity);
window.closePanel = () => { document.getElementById('selection-sheet').classList.remove('active'); state.selectedNodeId = null; render(); };

window.toggleDashboard = () => {
    const dash = document.getElementById('dashboard-modal'), hist = document.getElementById('history-modal');
    hist.style.display = 'none';
    dash.style.display = (dash.style.display === 'none' || !dash.style.display) ? 'block' : 'none';
    if (dash.style.display === 'block') updateDashboard();
};

window.toggleHistory = () => {
    const dash = document.getElementById('dashboard-modal'), hist = document.getElementById('history-modal');
    dash.style.display = 'none';
    hist.style.display = (hist.style.display === 'none' || !hist.style.display) ? 'block' : 'none';
    if (hist.style.display === 'block') renderHistoryCharts();
};

function updateDashboard() {
    if (document.getElementById('dashboard-modal').style.display === 'none') return;
    document.getElementById('dash-cash').innerText = Utils.fmtCurrency(state.cash);
    document.getElementById('dash-inv').innerText = Utils.formatInt(state.nodes.reduce((a,n) => a + n.inventory, 0));
    document.getElementById('dash-ships').innerText = Utils.formatInt(state.units.filter(u => u.type === 'ship').length);
    document.getElementById('dash-planes').innerText = Utils.formatInt(state.units.filter(u => u.type === 'air').length);

    const mList = document.getElementById('dash-markets');
    let html = `<div style="display:grid; grid-template-columns: 1fr 1.5fr 1fr 1fr; gap:8px; padding:8px 12px; font-size:12px; color:var(--text-secondary); text-transform:uppercase; font-weight:700;"><div>Market</div><div>Stock / Cap</div><div>Demand</div><div>Status</div></div>`;
    html += state.nodes.filter(n => n.type === 'market').map(m => {
        const fillRate = m.inventory / m.maxInventory;
        let status = fillRate < 0.1 ? '<span style="color:var(--accent-red)">Starving</span>' : (fillRate > 0.9 ? '<span style="color:var(--accent-yellow)">Full</span>' : '<span style="color:var(--accent-green)">Healthy</span>');
        return `<div style="background:rgba(255,255,255,0.03); padding:10px 12px; border-radius:8px; display:grid; grid-template-columns: 1fr 1.5fr 1fr 1fr; gap:8px; align-items:center; border:1px solid var(--panel-border); margin-bottom:6px;">
            <span style="font-weight:bold;">${m.name}</span><span style="font-family:monospace;">${Utils.formatInt(m.inventory)} / ${Utils.formatInt(m.maxInventory)}</span><span>${m.demand.toFixed(1)}/d</span><span>${status}</span>
        </div>`;
    }).join('');
    mList.innerHTML = html;
}

function renderHistoryCharts() {
    const modal = document.getElementById('history-modal');
    if (modal.style.display === 'none' || state.history.days.length < 2) {
        if (state.history.days.length < 2) document.getElementById('cash-chart').innerHTML = '<div style="padding:40px; text-align:center; color:var(--text-secondary);">Waiting for more data...</div>';
        return;
    }

    const draw = (containerId, datasets, colors, unit = "", options = {}) => {
        const container = document.getElementById(containerId);
        if (!container) return;
        container.innerHTML = '';
        const margin = {top: 10, right: 10, bottom: 25, left: 45}, w = container.clientWidth - margin.left - margin.right, h = container.clientHeight - margin.top - margin.bottom;
        
        const svg = d3.select(container).append("svg").attr("width", w + margin.left + margin.right).attr("height", h + margin.top + margin.bottom).append("g").attr("transform", `translate(${margin.left},${margin.top})`);
        
        const x = d3.scaleLinear().domain(d3.extent(state.history.days)).range([0, w]);
        
        // Calculate Y domain across all datasets
        let yMin = Infinity, yMax = -Infinity;
        datasets.forEach(data => {
            const min = d3.min(data);
            const max = d3.max(data);
            if (min !== undefined) yMin = Math.min(yMin, min);
            if (max !== undefined) yMax = Math.max(yMax, max);
        });

        if (options.yMin !== undefined) yMin = options.yMin;
        if (options.yMax !== undefined) yMax = options.yMax;
        
        if (yMin === Infinity) { yMin = 0; yMax = 100; }
        if (yMin === yMax) { yMin -= 1; yMax += 1; }

        const pad = (yMax - yMin) * 0.1 || 1;
        const y = d3.scaleLinear().domain([yMin - pad, yMax + pad]).range([h, 0]);

        svg.append("g").attr("transform", `translate(0,${h})`).call(d3.axisBottom(x).ticks(5).tickFormat(d => `D${Math.floor(d)}`)).attr("color", "#8b949e");
        svg.append("g").call(d3.axisLeft(y).ticks(5).tickFormat(d => d >= 1000 ? `${(d/1000).toFixed(0)}k` : d.toFixed(0) + unit)).attr("color", "#8b949e");

        datasets.forEach((data, i) => {
            const line = d3.line().x((d, idx) => x(state.history.days[idx])).y(d => y(d)).curve(d3.curveMonotoneX);
            svg.append("path").datum(data).attr("fill", "none").attr("stroke", colors[i]).attr("stroke-width", 2).attr("d", line);
            
            if (datasets.length === 1) { // Area fill for single lines
                const area = d3.area().x((d, idx) => x(state.history.days[idx])).y0(h).y1(d => y(d)).curve(d3.curveMonotoneX);
                svg.append("path").datum(data).attr("fill", colors[i]).attr("opacity", 0.1).attr("d", area);
            }
        });

        // Add reference lines
        if (options.referenceLine !== undefined) {
            svg.append("line")
                .attr("x1", 0).attr("x2", w)
                .attr("y1", y(options.referenceLine)).attr("y2", y(options.referenceLine))
                .attr("stroke", options.refColor || "#8b949e")
                .attr("stroke-width", 1)
                .attr("stroke-dasharray", "4,4");
        }
    };

    const maxGlobalInv = state.nodes.reduce((a,n) => a + n.maxInventory, 0);
    draw('cash-chart', [state.history.cash], ['var(--accent-blue)'], "$");
    draw('inv-chart', [state.history.inventory], ['var(--accent-green)'], "", { referenceLine: maxGlobalInv * 0.2, refColor: 'var(--accent-yellow)' });
    draw('margin-chart', [state.history.margin], ['var(--accent-yellow)'], "%");
    draw('balance-chart', [state.history.demand, state.history.production], ['var(--accent-red)', 'var(--accent-blue)']);
}

window.unlockNode = (id) => {
    const n = state.nodes.find(x => x.id === id);
    if (!n || !n.locked) return;
    
    if (state.cash >= n.unlockCost) {
        state.cash -= n.unlockCost;
        n.locked = false;
        
        // Ensure standard properties are active
        n.inventory = n.type === 'supply' ? 500 : 100;
        if (n.type === 'market') n.demand = n.baseDemand;
        
        // Ensure investment levels exist (should be there from init, but safety check)
        if (!n.levels) n.levels = { production: 1, quality: 1, automation: 1 };
        
        spawnParticle(state.projection(n.coords), "HUB BUILT!", "#3fb950");
        showNotification(`${n.name} Hub Construction Complete!`, "#3fb950");
        
        updateUI();
        
        // Force refresh sheet by closing and reopening slightly later or clearing attribute
        const container = document.getElementById('sheet-stats');
        if (container) container.removeAttribute('data-node-id'); // Force redraw
        
        openSheet(n); // Refresh sheet to show normal stats
    }
};

window.investNode = (id, type) => {
    const node = state.nodes.find(n => n.id === id);
    if (!node) return;
    
    // Ensure levels object exists
    if (!node.levels) node.levels = { production: 1, quality: 1, automation: 1 };
    
    const base = CONFIG.investment[type].cost;
    const lvl = node.levels[type];
    const cost = Math.floor(base * Math.pow(CONFIG.upgradeCosts.multiplier, lvl - 1));
    
    if (state.cash >= cost) {
        state.cash -= cost; 
        node.levels[type]++;
        
        // Apply Investment Effects
        if (type === 'production') {
            const boost = CONFIG.investment.production.boost;
            if (node.type === 'supply') { 
                node.production *= boost; 
                node.maxInventory *= boost; 
            } else if (node.type === 'make') { 
                node.processRate *= boost; 
                node.maxInventory *= boost;
                // Update route intervals for higher throughput
                state.routes.filter(r => r.to === node.id).forEach(r => {
                    const factor = CONFIG.transport[r.type].intervalFactor;
                    r.interval = (CONFIG.transport[r.type].capacity / Math.max(1, node.processRate)) * 1000 * factor;
                });
            } else if (node.type === 'market') { 
                node.baseDemand *= boost; 
                node.maxInventory *= boost; 
            }
        }
        // Quality and Automation effects are applied dynamically in updateEconomy/updateUnits based on level
        
        const label = CONFIG.investment[type].label;
        spawnParticle(state.projection(node.coords), `${label} UP!`, "#ffd700");
        showNotification(`${node.name}: ${label} upgraded to Lv ${node.levels[type]}`, "#ffd700");
        updateUI(); 
        updateSheetStats(node); // Refresh UI
    }
};

window.startGame = () => { 
    const title = document.getElementById('title-screen');
    if (title) title.style.display = 'none'; 
    
    const yearEl = document.getElementById('year-display');
    if (yearEl) yearEl.innerText = `Year ${state.currentYear} / ${state.durationYears}`;
    
    state.yearlyCashStart = state.cash;
    setSpeed(0); updateUI(); 
};

window.endGame = () => {
    state.speed = 0; document.getElementById('end-screen').style.display = 'flex';
    document.getElementById('final-cash').innerText = Utils.fmtCurrency(state.cash);
    
    // 1. Avg Freshness at Markets
    const markets = state.nodes.filter(n => n.type === 'market');
    const avgFresh = markets.reduce((acc, m) => acc + m.quality, 0) / (markets.length || 1);
    const freshEl = document.getElementById('final-fresh');
    freshEl.innerText = (avgFresh * 100).toFixed(0) + '%';
    freshEl.style.color = avgFresh > 0.8 ? 'var(--accent-green)' : (avgFresh > 0.5 ? 'var(--accent-yellow)' : 'var(--accent-red)');

    // 2. Total Missed Sales (as currency)
    document.getElementById('final-missed').innerText = Utils.fmtCurrency(state.totalLostRevenue);

    // 3. Inventory Turnover = Total Sales / Avg Global Inventory
    const histInv = state.history.inventory;
    const avgInv = histInv.length > 0 ? histInv.reduce((a,b)=>a+b,0)/histInv.length : state.nodes.reduce((a,n)=>a+n.inventory,0);
    const turnover = avgInv > 0 ? state.totalSales / avgInv : 0;
    document.getElementById('final-turnover').innerText = turnover.toFixed(1) + 'x';
};

window.replayGame = () => { 
    document.getElementById('end-screen').style.display = 'none'; 
    document.getElementById('dashboard-modal').style.display = 'none';
    document.getElementById('history-modal').style.display = 'none';
    document.getElementById('report-modal').style.display = 'none';
    closePanel(); // Ensure panel is closed
    resetState(); initGameLogic(); setSpeed(0); resetZoom(); updateUI(); document.getElementById('title-screen').style.display = 'flex'; 
};

function resetState() {
    // Preserve system-critical objects before resetting
    const sys = {
        projection: state.projection,
        pathGenerator: state.pathGenerator,
        zoomBehavior: state.zoomBehavior,
        ctx: state.ctx,
        svg: state.svg,
        g: state.g,
        width: state.width,
        height: state.height,
        transform: d3.zoomIdentity // Reset zoom on replay
    };

    state = getInitialState();

    // Restore system objects
    Object.assign(state, sys);
}

init();
</script>
</body>
</html>
